---
description: Go development best practices and conventions for exarp-go
alwaysApply: true
---

# üêπ Go Development Best Practices

**‚ö†Ô∏è AI MUST FOLLOW THESE PRACTICES FOR ALL GO CODE GENERATION ‚ö†Ô∏è**

## Essential Go Principles

‚Ä¢ **Idiomatic Go** - Follow Go conventions, use standard library first
‚Ä¢ **Error handling** - Always handle errors explicitly, never ignore them
‚Ä¢ **Interface-driven design** - Use interfaces for abstraction and testability
‚Ä¢ **Package organization** - Clear package boundaries, minimal public API
‚Ä¢ **Concurrency safety** - Use channels, sync primitives correctly
‚Ä¢ **Zero values** - Leverage Go's zero values for sensible defaults
‚Ä¢ **Documentation** - Export only what needs to be exported, document public APIs
‚Ä¢ **Testing** - Write table-driven tests, use test helpers, benchmark critical paths

## Go Code Style

### Naming Conventions
- **Packages**: lowercase, single word, descriptive (`server`, `tools`, `framework`)
- **Exported functions**: PascalCase, descriptive verbs (`RegisterTool`, `HandleRequest`)
- **Unexported functions**: camelCase (`registerTool`, `handleRequest`)
- **Constants**: PascalCase for exported, camelCase for unexported
- **Interfaces**: Single method = method name + "er" (`Reader`, `Writer`), multiple methods = descriptive name (`MCPServer`)

### Error Handling
```go
// ‚úÖ GOOD: Explicit error handling
result, err := doSomething()
if err != nil {
    return fmt.Errorf("failed to do something: %w", err)
}

// ‚ùå BAD: Ignoring errors
result, _ := doSomething()

// ‚úÖ GOOD: Wrapping errors with context
if err != nil {
    return fmt.Errorf("registering tool %s: %w", toolName, err)
}
```

### Interface Design
```go
// ‚úÖ GOOD: Small, focused interfaces
type ToolHandler interface {
    Handle(ctx context.Context, args json.RawMessage) (json.RawMessage, error)
}

// ‚úÖ GOOD: Interface composition
type MCPServer interface {
    RegisterTool(name string, handler ToolHandler) error
    Run(ctx context.Context) error
}

// ‚ùå BAD: Large, monolithic interfaces
type Everything interface {
    // 20+ methods...
}
```

### Package Organization
```
cmd/
  server/
    main.go          # Application entry point
internal/
  framework/         # Framework abstraction layer
    server.go        # MCPServer interface
    factory.go       # Framework factory
  adapters/          # Framework-specific adapters
    gosdk/
    mcpgo/
    gomcp/
  tools/             # Tool implementations
  prompts/           # Prompt implementations
  resources/         # Resource implementations
pkg/                 # Public API (if needed)
  api/               # Public interfaces
```

## Go-Specific Patterns

### Context Usage
```go
// ‚úÖ GOOD: Always accept context as first parameter
func (s *Server) RegisterTool(ctx context.Context, name string, handler ToolHandler) error {
    // Check context cancellation
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
    }
    // ... implementation
}

// ‚úÖ GOOD: Pass context through call chain
func (s *Server) Run(ctx context.Context) error {
    return s.handleRequests(ctx)
}
```

### Concurrency
```go
// ‚úÖ GOOD: Use channels for communication
type Server struct {
    requests chan Request
    done     chan struct{}
}

// ‚úÖ GOOD: Use sync primitives when needed
type Counter struct {
    mu    sync.RWMutex
    count int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.count++
}
```

### Testing
```go
// ‚úÖ GOOD: Table-driven tests
func TestRegisterTool(t *testing.T) {
    tests := []struct {
        name    string
        tool    Tool
        wantErr bool
    }{
        {
            name: "valid tool",
            tool: Tool{Name: "test", Handler: mockHandler},
            wantErr: false,
        },
        {
            name: "empty name",
            tool: Tool{Name: "", Handler: mockHandler},
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := server.RegisterTool(tt.tool)
            if (err != nil) != tt.wantErr {
                t.Errorf("RegisterTool() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}
```

### Count Synchronization (CRITICAL)
**‚ö†Ô∏è ALWAYS KEEP COUNTS IN SYNC BETWEEN IMPLEMENTATION, COMMENTS, AND TESTS ‚ö†Ô∏è**

When registering items (tools, prompts, resources, etc.):
1. **Count items in implementation** - Count actual items being registered
2. **Update comments** - Update any comments that mention the count
3. **Update test expectations** - Update test assertions that check counts
4. **Update expected lists** - Add new items to test expected lists

**Example - Prompt Registration:**
```go
// ‚ùå BAD: Count mismatch
// Register 17 prompts (8 original + 7 workflow + 2 mcp-generic-tools)
prompts := []struct{...}{
    {"align", "..."},
    // ... 17 prompts ...
    {"task_update", "..."}, // NEW: 18th prompt added but comment not updated
}

// Test expects 17 but gets 18
if server.PromptCount() != 17 { // ‚ùå WRONG
    t.Errorf("server.PromptCount() = %v, want 17", server.PromptCount())
}

// ‚úÖ GOOD: All counts in sync
// Register 18 prompts (8 original + 7 workflow + 2 mcp-generic-tools + 1 task management)
prompts := []struct{...}{
    {"align", "..."},
    // ... 18 prompts ...
    {"task_update", "..."},
}

// Test expects 18
if server.PromptCount() != 18 { // ‚úÖ CORRECT
    t.Errorf("server.PromptCount() = %v, want 18", server.PromptCount())
}

// Test list includes all 18 prompts
expectedPrompts := []string{
    "align", "discover", // ... all 18 prompts including "task_update"
}
```

**Checklist When Adding/Removing Items:**
- ‚úÖ Count items in implementation code
- ‚úÖ Update comment with new count and breakdown
- ‚úÖ Update test count assertion
- ‚úÖ Add/remove item from test expected lists
- ‚úÖ Verify test passes with updated counts

## MCP Server Specific Guidelines

### Framework-Agnostic Design
- **Use interfaces** for all framework interactions
- **Factory pattern** for framework selection
- **Adapter pattern** for framework-specific implementations
- **Configuration-driven** framework selection

### Tool Registration
```go
// ‚úÖ GOOD: Interface-based tool registration
type ToolRegistry interface {
    RegisterTool(name, description string, schema ToolSchema, handler ToolHandler) error
    ListTools() []ToolInfo
}

// ‚úÖ GOOD: Type-safe tool handlers
type ToolHandler func(ctx context.Context, args json.RawMessage) (json.RawMessage, error)
```

### Resource Management
```go
// ‚úÖ GOOD: Resource handlers with proper error handling
type ResourceHandler func(ctx context.Context, uri string) ([]byte, string, error)

// ‚úÖ GOOD: Resource metadata
type Resource struct {
    URI         string
    Name        string
    Description string
    MimeType    string
    Handler     ResourceHandler
}
```

## Migration-Specific Guidelines

### Framework Switching
- **Configuration-based** framework selection
- **No hard dependencies** on specific framework
- **Adapter pattern** for framework abstraction
- **Easy testing** with mock adapters

## Performance Considerations

### Memory Management
- **Avoid allocations** in hot paths
- **Use sync.Pool** for frequently allocated objects
- **Buffer reuse** for I/O operations
- **Profile before optimizing**

### Concurrency
- **Goroutine pools** for parallel tool execution
- **Context cancellation** for request timeouts
- **Channel buffering** for throughput optimization
- **Avoid goroutine leaks**

## Security Best Practices

### Input Validation
```go
// ‚úÖ GOOD: Validate all inputs
func (s *Server) RegisterTool(name string, handler ToolHandler) error {
    if name == "" {
        return fmt.Errorf("tool name cannot be empty")
    }
    if handler == nil {
        return fmt.Errorf("tool handler cannot be nil")
    }
    // ... sanitize name, check for conflicts
}
```

### Error Messages
```go
// ‚úÖ GOOD: Don't leak sensitive information
return fmt.Errorf("authentication failed")

// ‚ùå BAD: Leak sensitive information
return fmt.Errorf("authentication failed: invalid password %q", password)
```

## Documentation Standards

### Package Documentation
```go
// Package server provides an MCP server implementation.
//
// The server supports multiple MCP frameworks through a framework-agnostic
// interface, allowing easy switching between implementations.
package server
```

### Function Documentation
```go
// RegisterTool registers a new tool with the MCP server.
//
// The tool name must be unique and follow MCP naming conventions.
// The handler will be called when the tool is invoked by a client.
//
// Returns an error if the tool name is invalid or already registered.
func (s *Server) RegisterTool(name string, handler ToolHandler) error {
    // ...
}
```

## Dependencies Management

### Go Modules
- **Use go.mod** for dependency management
- **Pin versions** for production dependencies
- **Minimal dependencies** - prefer standard library
- **Vendor dependencies** for reproducible builds (if needed)

### Framework Dependencies
- **Framework adapters** in separate packages
- **No direct framework imports** in core code
- **Interface-based** framework interaction
- **Easy to swap** frameworks via configuration

### Graph Analysis Libraries
- **gonum.org/v1/gonum/graph** - Used for graph algorithms (cycle detection, topological sort, critical path)
- **Prefer gonum over manual implementations** for complex graph operations
- **Use wrapper types** (TaskGraph) to add domain-specific metadata to graph nodes
- **Performance**: Gonum provides optimized algorithms (O(V + E) for most operations)

## Graph Algorithms and Analysis

### Gonum Graph Library Usage

**When to Use Gonum:**
- Dependency analysis (task dependencies, circular dependencies)
- Critical path analysis (longest path in DAG)
- Topological sorting
- Cycle detection
- Complex graph algorithms beyond simple maps

**TaskGraph Wrapper Pattern:**
```go
// ‚úÖ GOOD: Wrapper with domain-specific metadata
type TaskGraph struct {
    Graph     *simple.DirectedGraph
    TaskIDMap map[string]int64  // task ID -> node ID
    NodeIDMap map[int64]string  // node ID -> task ID
    NodeMap   map[int64]*TaskNode
}

// ‚úÖ GOOD: Custom node type with metadata
type TaskNode struct {
    NodeID   int64  // Internal graph node ID
    TaskID   string // Domain-specific task ID
    Name     string
    Priority string
    Status   string
}

func (n *TaskNode) ID() int64 {
    return n.NodeID
}
```

**Graph Building:**
```go
// ‚úÖ GOOD: Build graph from domain objects
func BuildTaskGraph(tasks []Todo2Task) (*TaskGraph, error) {
    tg := NewTaskGraph()
    
    // Add all tasks as nodes first
    for _, task := range tasks {
        tg.AddTask(task)
    }
    
    // Then add dependency edges
    for _, task := range tasks {
        for _, depID := range task.Dependencies {
            if err := tg.AddDependency(depID, task.ID); err != nil {
                return nil, err
            }
        }
    }
    
    return tg, nil
}
```

**Cycle Detection:**
```go
// ‚úÖ GOOD: Use topo.Sort for efficient cycle detection
func HasCycles(tg *TaskGraph) (bool, error) {
    _, err := topo.Sort(tg.Graph)
    if err != nil {
        return true, nil  // Sort fails if cycles exist
    }
    return false, nil
}

// ‚úÖ GOOD: Custom cycle enumeration when needed (gonum lacks simple_cycles)
func DetectCycles(tg *TaskGraph) [][]string {
    // Use DFS to enumerate all cycles
    // Gonum provides topo.Sort but not cycle enumeration
}
```

**Critical Path Analysis:**
```go
// ‚úÖ GOOD: Use dynamic programming with topological sort
func FindCriticalPath(tg *TaskGraph) ([]string, error) {
    // Check for cycles first
    hasCycles, err := HasCycles(tg)
    if err != nil || hasCycles {
        return nil, fmt.Errorf("cannot find critical path: graph has cycles")
    }
    
    // Get topological sort
    sorted, err := TopoSortTasks(tg)
    if err != nil {
        return nil, err
    }
    
    // Dynamic programming: calculate longest path
    dist := make(map[string]int)
    prev := make(map[string]string)
    
    for _, taskID := range sorted {
        // Update distance from dependencies
        // Track path for reconstruction
    }
    
    // Reconstruct path from end to start
    return path, nil
}
```

**Dependency Level Calculation:**
```go
// ‚úÖ GOOD: Optimize with topological sort for acyclic graphs
func GetTaskLevels(tg *TaskGraph) map[string]int {
    hasCycles, _ := HasCycles(tg)
    if !hasCycles {
        // Use topological sort for O(V + E) performance
        sorted, _ := topo.Sort(tg.Graph)
        // Process in order, single pass
    } else {
        // Fallback to iterative approach for cyclic graphs
    }
}
```

**Performance Considerations:**
- **Graph Building**: O(V + E) - acceptable overhead
- **Cycle Detection**: O(V + E) - very fast with topo.Sort
- **Topological Sort**: O(V + E) - optimal algorithm
- **Critical Path**: O(V + E) - dynamic programming approach
- **GetTaskLevels**: O(V + E) for acyclic, O(V * E) worst case for cyclic
- **Memory**: ~20-30% overhead vs manual map-based graphs (acceptable trade-off)

**Testing Graph Algorithms:**
```go
// ‚úÖ GOOD: Test with various graph structures
func TestFindCriticalPath(t *testing.T) {
    tests := []struct {
        name  string
        tasks []Todo2Task
        want  []string
    }{
        {
            name:  "linear chain",
            tasks: generateTestTasks(10, 1),
            want:  []string{"T-1", "T-2", ..., "T-10"},
        },
        {
            name: "complex graph",
            tasks: generateComplexTasks(),
            want: []string{...},
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tg, _ := BuildTaskGraph(tt.tasks)
            got, err := FindCriticalPath(tg)
            // Verify correctness
        })
    }
}

// ‚úÖ GOOD: Benchmark graph operations
func BenchmarkBuildTaskGraph(b *testing.B) {
    tasks := generateTestTasks(200, 3)
    for i := 0; i < b.N; i++ {
        _, _ = BuildTaskGraph(tasks)
    }
}
```

**When NOT to Use Gonum:**
- Simple adjacency list needs (use `map[string][]string`)
- Very small graphs (< 10 nodes) where overhead isn't worth it
- Operations that don't benefit from graph algorithms

## Todo2 Database Integration

### SQLite Database (Primary Storage)

**‚ö†Ô∏è CRITICAL: Todo2 now uses SQLite database as primary storage ‚ö†Ô∏è**

**Storage Architecture:**
- **Primary**: `.todo2/todo2.db` (SQLite database) - **USE THIS**
- **Fallback**: `.todo2/state.todo2.json` (legacy JSON file, only used if database unavailable)

**Key Functions (Database-First with Fallback):**
```go
// LoadTodo2Tasks loads from database first, falls back to JSON if needed
tasks, err := tools.LoadTodo2Tasks(projectRoot)

// SaveTodo2Tasks saves to database first, falls back to JSON if needed
err := tools.SaveTodo2Tasks(projectRoot, tasks)
```

**Direct Database Operations (When Database Available):**
```go
import "github.com/davidl71/exarp-go/internal/database"

// Single task operations (O(1) - efficient)
task, err := database.GetTask(taskID)
err := database.CreateTask(&task)
err := database.UpdateTask(&task)
err := database.DeleteTask(taskID)

// Batch operations with filtering (efficient)
filters := &database.TaskFilters{
    Status: &status,  // Filter by status
    Tag: &tag,        // Filter by tag
    Priority: &priority,
}
tasks, err := database.ListTasks(filters)

// Comments
comments, err := database.GetComments(taskID)
err := database.AddComments(taskID, comments)
```

**Performance Benefits (vs JSON):**
- **Single task ops**: O(1) query + O(1) update (vs O(n) read/write with JSON)
- **Filtered queries**: Only load matching tasks, not entire file
- **Direct deletions**: No need to load/rewrite entire file
- **Batch operations**: Efficient transactions
- **Indexed queries**: Fast lookups by status, tag, priority

**Database Initialization:**
- ‚úÖ Automatically initialized in `cmd/server/main.go` and `internal/cli/cli.go`
- ‚úÖ Creates database file if it doesn't exist
- ‚úÖ Runs schema migrations automatically
- ‚úÖ Graceful error handling with automatic JSON fallback

**Migration Tool:**
```bash
# Preview migration (dry run)
./bin/migrate --dry-run

# Migrate existing JSON data to SQLite (creates backup)
./bin/migrate --backup

# Specify project root manually
./bin/migrate --project-root /path/to/project
```

**Best Practices:**
- ‚úÖ **Use `LoadTodo2Tasks()` / `SaveTodo2Tasks()`** for compatibility (handles database/JSON automatically)
- ‚úÖ **Use direct database operations** when you need filtering or single-task ops (more efficient)
- ‚úÖ **Database-first approach**: All new code should assume database is primary storage
- ‚úÖ **Graceful degradation**: Code should work even if database unavailable (falls back to JSON)
- ‚úÖ **Transaction safety**: Use database transactions for multi-step operations

**When to Use Database Functions Directly:**
- Filtering tasks by status/tag/priority (use `database.ListTasks()` with filters)
- Single task retrieval/update (use `database.GetTask()` / `database.UpdateTask()`)
- Efficient deletions (use `database.DeleteTask()`)
- Batch operations with transactions

**When to Use LoadTodo2Tasks/SaveTodo2Tasks:**
- Compatibility with existing code
- When you need to load ALL tasks (no filtering needed)
- When database availability is uncertain (automatic fallback)

**File Locations:**
- Database: `.todo2/todo2.db` (SQLite)
- JSON (fallback): `.todo2/state.todo2.json` (legacy)
- Backup: `.todo2/state.todo2.json.backup` (created during migration)

## Makefile Usage (CRITICAL)

**‚ö†Ô∏è ALWAYS USE MAKEFILE TARGETS INSTEAD OF DIRECT COMMANDS ‚ö†Ô∏è**

**Before running any command, check if a Makefile target exists. Use `make <target>` instead of generating files or running commands directly.**

### Available Makefile Targets

**Shortcuts (prefer when suggesting commands):** `make b` = build, `make r` / `make root` = print repo root. See `.cursor/rules/make-shortcuts.mdc`.

**Build Operations:**
- `make build` - Build the Go server (without CGO by default)
- `make b` - Short alias for build
- `make silent` - Run default build (all) with minimal output; prefer when terminal noise should be reduced
- `make go-build` - Build Go binary
- `make build-apple-fm` - Build with Apple Foundation Models support (CGO_ENABLED=1)
- `make build-swift-bridge` - Build Swift bridge for go-foundationmodels
- `make build-migrate` - Build JSON to SQLite migration tool

**Development Operations:**
- `make run` - Run the MCP server (builds first)
- `make dev` - Start development mode (auto-reload on changes)
- `make dev-watch` - Watch files and auto-reload (alias for dev)
- `make dev-test` - Development mode with auto-test on changes
- `make dev-full` - Full development mode (watch + test + coverage)
- `make go-dev` - Start Go development mode (hot reload)
- `make go-dev-test` - Go dev mode with auto-test
- `make go-run` - Run Go binary

**Testing:**
- `make test` - Run all tests (Go + Python)
- `make test-go` - Run Go tests
- `make test-integration` - Run integration tests
- `make test-coverage` - Run tests with coverage report
- `make test-coverage-go` - Generate Go test coverage report
- `make test-html` - Generate HTML coverage reports
- `make test-watch` - Run tests in watch mode
- `make test-tools` - Test Go server tools
- `make test-all` - Run all import tests + sanity check + CLI tests
- `make test-cli` - Run all CLI functionality tests
- `make go-test` - Run Go tests
- `make test-apple-fm` - Run all Apple Foundation Models tests

**Code Quality:**
- `make fmt` - Format code with exarp-go (gofmt/goimports) (requires build)
- `make lint` - Lint code with exarp-go (requires build)
- `make lint-fix` - Lint and auto-fix code with exarp-go (requires build)
- `make clean` - Clean build artifacts and cache
- `make clean-all` - Clean everything including virtual environment
- `make clean-config` - Remove configuration file

**Configuration:**
- `make config` - Configure build system (detect available tools)
- `make sanity-check` - Verify tools/resources/prompts counts match expected values

**Installation:**
- `make install` - Install exarp-go binary

**Benchmarking:**
- `make bench` - Run benchmarks (requires pytest)
- `make go-bench` - Run Go benchmarks

**Documentation:**
- `make docs` - Generate documentation

**Sprint Automation:**
- `make sprint-start` - Run sprint start workflow (clean backlog, align tasks)
- `make sprint-end` - Run sprint end workflow (test coverage, docs, security)
- `make pre-sprint` - Run pre-sprint cleanup (duplicates, alignment, docs)
- `make sprint` - Run full sprint automation (process all background tasks)

**Task and queue (Todo2 / Redis+Asynq):**
- `make task-list` - List tasks (use `TASK_FLAGS="--status Todo"` to filter)
- `make task-list-todo` - List Todo tasks
- `make task-update` - Update status: `make task-update TASK_ID=T-123 NEW_STATUS=Done`
- `make task-create` - Create task: `make task-create TASK_NAME="Title" TASK_DESC="..." TASK_PRIORITY=medium`
- `make queue-enqueue-wave` - Enqueue wave to Redis+Asynq (set `WAVE=0` or `WAVE=1`; requires `REDIS_ADDR`)
- `make queue-worker` - Run Asynq worker (requires `REDIS_ADDR`)
- **Env (optional):** `REDIS_ADDR=127.0.0.1:6379` for queue/worker; see `docs/EXARP_CLI_SHORTCUTS.md` for aliases and all targets.

**Task Completion Detection (native Go infer_task_progress):**
- `make check-tasks` - Batch check In Progress tasks to find completed ones (dry run, no updates). Uses `exarp-go -tool infer_task_progress`; report written to docs/TASK_COMPLETION_CHECK.md.
- `make update-completed-tasks` - Batch check and auto-update completed tasks (updates task status based on codebase analysis). Same tool with auto_update_tasks=true; report to docs/TASK_COMPLETION_UPDATE.md.

**Data Migration:**
- `make build-migrate` - Build JSON to SQLite migration tool
- `make migrate` - Run migration tool (requires build-migrate first)
- `make migrate-dry-run` - Preview migration without actually migrating

**Protobuf:**
- `make proto` - Generate Go from `.proto` files (tools, todo2, config, bridge)
- `make proto-check` - Validate `.proto` syntax
- `make proto-clean` - Remove generated `.pb.go` files

**Quick Commands:**
- `make all` - Build essential components and run sanity tests (default)
- `make help` - Show help message with all available targets

### Rules for AI

1. **NEVER run `go build` directly** - Use `make build` or `make go-build` instead
2. **NEVER run `go test` directly** - Use `make test`, `make test-go`, `make test-coverage`, or `make test-html` instead
3. **NEVER run linting tools directly** - Use `make lint` or `make lint-fix` instead
4. **NEVER run formatting tools directly** - Use `make fmt` instead
5. **NEVER create build scripts** - Use existing Makefile targets
6. **NEVER generate wrapper scripts** - Use `make dev`, `make go-dev`, or other dev targets
7. **ALWAYS check Makefile first** - Before suggesting any command, verify if a Makefile target exists
8. **PREFER Makefile targets** - When multiple options exist, choose the Makefile target
9. **PREFER `make silent`** - For routine builds (e.g. before commit, verification), use `make silent` to reduce terminal output
10. **Use `make config` first** - If tools are not detected, run `make config` to configure the build system
11. **NEVER edit `proto/*.pb.go`** - Generated files. Change `proto/*.proto` and run `make proto` to regenerate

### Examples

**‚ùå WRONG:**
```bash
go build -o bin/exarp-go ./cmd/server
go test ./...
golangci-lint run ./...
```

**‚úÖ CORRECT:**
```bash
make build
make test
make lint
```

**Exception:** Only use direct commands when:
- The operation is not covered by any Makefile target
- You need to pass custom flags not supported by Makefile targets
- You're debugging a specific issue that requires direct command execution
- `uv` is not available and operation cannot use Makefile target

## AI Enforcement Checklist

**Before generating Go code, ensure:**
- ‚úÖ Follows Go naming conventions
- ‚úÖ Handles all errors explicitly
- ‚úÖ Uses context for cancellation/timeouts
- ‚úÖ Implements interfaces for testability
- ‚úÖ Includes appropriate documentation
- ‚úÖ Uses table-driven tests
- ‚úÖ Follows framework-agnostic design
- ‚úÖ Validates all inputs
- ‚úÖ Uses idiomatic Go patterns
- ‚úÖ No goroutine leaks
- ‚úÖ Proper resource cleanup
- ‚úÖ **Uses Makefile targets instead of direct commands**
- ‚úÖ **Uses gonum graph for complex graph operations** (when applicable)
- ‚úÖ **Wraps gonum graphs with domain-specific types** for metadata
- ‚úÖ **Uses SQLite database as primary storage** (with JSON fallback)
- ‚úÖ **Prefers direct database operations** for filtering and single-task ops

**These practices are mandatory for professional Go development.**
