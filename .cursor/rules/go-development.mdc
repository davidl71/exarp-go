---
description: Go development best practices and conventions for exarp-go
alwaysApply: true
---

# üêπ Go Development Best Practices

**‚ö†Ô∏è AI MUST FOLLOW THESE PRACTICES FOR ALL GO CODE GENERATION ‚ö†Ô∏è**

## Essential Go Principles

‚Ä¢ **Idiomatic Go** - Follow Go conventions, use standard library first
‚Ä¢ **Error handling** - Always handle errors explicitly, never ignore them
‚Ä¢ **Interface-driven design** - Use interfaces for abstraction and testability
‚Ä¢ **Package organization** - Clear package boundaries, minimal public API
‚Ä¢ **Concurrency safety** - Use channels, sync primitives correctly
‚Ä¢ **Zero values** - Leverage Go's zero values for sensible defaults
‚Ä¢ **Documentation** - Export only what needs to be exported, document public APIs
‚Ä¢ **Testing** - Write table-driven tests, use test helpers, benchmark critical paths

## Go Code Style

### Naming Conventions
- **Packages**: lowercase, single word, descriptive (`server`, `tools`, `framework`)
- **Exported functions**: PascalCase, descriptive verbs (`RegisterTool`, `HandleRequest`)
- **Unexported functions**: camelCase (`registerTool`, `handleRequest`)
- **Constants**: PascalCase for exported, camelCase for unexported
- **Interfaces**: Single method = method name + "er" (`Reader`, `Writer`), multiple methods = descriptive name (`MCPServer`)

### Error Handling
```go
// ‚úÖ GOOD: Explicit error handling
result, err := doSomething()
if err != nil {
    return fmt.Errorf("failed to do something: %w", err)
}

// ‚ùå BAD: Ignoring errors
result, _ := doSomething()

// ‚úÖ GOOD: Wrapping errors with context
if err != nil {
    return fmt.Errorf("registering tool %s: %w", toolName, err)
}
```

### Interface Design
```go
// ‚úÖ GOOD: Small, focused interfaces
type ToolHandler interface {
    Handle(ctx context.Context, args json.RawMessage) (json.RawMessage, error)
}

// ‚úÖ GOOD: Interface composition
type MCPServer interface {
    RegisterTool(name string, handler ToolHandler) error
    Run(ctx context.Context) error
}

// ‚ùå BAD: Large, monolithic interfaces
type Everything interface {
    // 20+ methods...
}
```

### Package Organization
```
cmd/
  server/
    main.go          # Application entry point
internal/
  framework/         # Framework abstraction layer
    server.go        # MCPServer interface
    factory.go       # Framework factory
  adapters/          # Framework-specific adapters
    gosdk/
    mcpgo/
    gomcp/
  tools/             # Tool implementations
  prompts/           # Prompt implementations
  resources/         # Resource implementations
pkg/                 # Public API (if needed)
  api/               # Public interfaces
```

## Go-Specific Patterns

### Context Usage
```go
// ‚úÖ GOOD: Always accept context as first parameter
func (s *Server) RegisterTool(ctx context.Context, name string, handler ToolHandler) error {
    // Check context cancellation
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
    }
    // ... implementation
}

// ‚úÖ GOOD: Pass context through call chain
func (s *Server) Run(ctx context.Context) error {
    return s.handleRequests(ctx)
}
```

### Concurrency
```go
// ‚úÖ GOOD: Use channels for communication
type Server struct {
    requests chan Request
    done     chan struct{}
}

// ‚úÖ GOOD: Use sync primitives when needed
type Counter struct {
    mu    sync.RWMutex
    count int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.count++
}
```

### Testing
```go
// ‚úÖ GOOD: Table-driven tests
func TestRegisterTool(t *testing.T) {
    tests := []struct {
        name    string
        tool    Tool
        wantErr bool
    }{
        {
            name: "valid tool",
            tool: Tool{Name: "test", Handler: mockHandler},
            wantErr: false,
        },
        {
            name: "empty name",
            tool: Tool{Name: "", Handler: mockHandler},
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := server.RegisterTool(tt.tool)
            if (err != nil) != tt.wantErr {
                t.Errorf("RegisterTool() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}
```

## MCP Server Specific Guidelines

### Framework-Agnostic Design
- **Use interfaces** for all framework interactions
- **Factory pattern** for framework selection
- **Adapter pattern** for framework-specific implementations
- **Configuration-driven** framework selection

### Tool Registration
```go
// ‚úÖ GOOD: Interface-based tool registration
type ToolRegistry interface {
    RegisterTool(name, description string, schema ToolSchema, handler ToolHandler) error
    ListTools() []ToolInfo
}

// ‚úÖ GOOD: Type-safe tool handlers
type ToolHandler func(ctx context.Context, args json.RawMessage) (json.RawMessage, error)
```

### Resource Management
```go
// ‚úÖ GOOD: Resource handlers with proper error handling
type ResourceHandler func(ctx context.Context, uri string) ([]byte, string, error)

// ‚úÖ GOOD: Resource metadata
type Resource struct {
    URI         string
    Name        string
    Description string
    MimeType    string
    Handler     ResourceHandler
}
```

## Migration-Specific Guidelines

### Python Bridge Integration
- **Use exec.Command** for Python bridge calls
- **PREFER `uv run python`** - Use `uv run python` instead of `python3` when possible
- **Check for uv first** - Detect `uv` availability before falling back to `python3`
- **JSON-RPC 2.0** for communication protocol
- **Error propagation** from Python to Go
- **Timeout handling** for long-running Python operations

### Framework Switching
- **Configuration-based** framework selection
- **No hard dependencies** on specific framework
- **Adapter pattern** for framework abstraction
- **Easy testing** with mock adapters

## Performance Considerations

### Memory Management
- **Avoid allocations** in hot paths
- **Use sync.Pool** for frequently allocated objects
- **Buffer reuse** for I/O operations
- **Profile before optimizing**

### Concurrency
- **Goroutine pools** for parallel tool execution
- **Context cancellation** for request timeouts
- **Channel buffering** for throughput optimization
- **Avoid goroutine leaks**

## Security Best Practices

### Input Validation
```go
// ‚úÖ GOOD: Validate all inputs
func (s *Server) RegisterTool(name string, handler ToolHandler) error {
    if name == "" {
        return fmt.Errorf("tool name cannot be empty")
    }
    if handler == nil {
        return fmt.Errorf("tool handler cannot be nil")
    }
    // ... sanitize name, check for conflicts
}
```

### Error Messages
```go
// ‚úÖ GOOD: Don't leak sensitive information
return fmt.Errorf("authentication failed")

// ‚ùå BAD: Leak sensitive information
return fmt.Errorf("authentication failed: invalid password %q", password)
```

## Documentation Standards

### Package Documentation
```go
// Package server provides an MCP server implementation.
//
// The server supports multiple MCP frameworks through a framework-agnostic
// interface, allowing easy switching between implementations.
package server
```

### Function Documentation
```go
// RegisterTool registers a new tool with the MCP server.
//
// The tool name must be unique and follow MCP naming conventions.
// The handler will be called when the tool is invoked by a client.
//
// Returns an error if the tool name is invalid or already registered.
func (s *Server) RegisterTool(name string, handler ToolHandler) error {
    // ...
}
```

## Dependencies Management

### Go Modules
- **Use go.mod** for dependency management
- **Pin versions** for production dependencies
- **Minimal dependencies** - prefer standard library
- **Vendor dependencies** for reproducible builds (if needed)

### Framework Dependencies
- **Framework adapters** in separate packages
- **No direct framework imports** in core code
- **Interface-based** framework interaction
- **Easy to swap** frameworks via configuration

### Graph Analysis Libraries
- **gonum.org/v1/gonum/graph** - Used for graph algorithms (cycle detection, topological sort, critical path)
- **Prefer gonum over manual implementations** for complex graph operations
- **Use wrapper types** (TaskGraph) to add domain-specific metadata to graph nodes
- **Performance**: Gonum provides optimized algorithms (O(V + E) for most operations)

## Graph Algorithms and Analysis

### Gonum Graph Library Usage

**When to Use Gonum:**
- Dependency analysis (task dependencies, circular dependencies)
- Critical path analysis (longest path in DAG)
- Topological sorting
- Cycle detection
- Complex graph algorithms beyond simple maps

**TaskGraph Wrapper Pattern:**
```go
// ‚úÖ GOOD: Wrapper with domain-specific metadata
type TaskGraph struct {
    Graph     *simple.DirectedGraph
    TaskIDMap map[string]int64  // task ID -> node ID
    NodeIDMap map[int64]string  // node ID -> task ID
    NodeMap   map[int64]*TaskNode
}

// ‚úÖ GOOD: Custom node type with metadata
type TaskNode struct {
    NodeID   int64  // Internal graph node ID
    TaskID   string // Domain-specific task ID
    Name     string
    Priority string
    Status   string
}

func (n *TaskNode) ID() int64 {
    return n.NodeID
}
```

**Graph Building:**
```go
// ‚úÖ GOOD: Build graph from domain objects
func BuildTaskGraph(tasks []Todo2Task) (*TaskGraph, error) {
    tg := NewTaskGraph()
    
    // Add all tasks as nodes first
    for _, task := range tasks {
        tg.AddTask(task)
    }
    
    // Then add dependency edges
    for _, task := range tasks {
        for _, depID := range task.Dependencies {
            if err := tg.AddDependency(depID, task.ID); err != nil {
                return nil, err
            }
        }
    }
    
    return tg, nil
}
```

**Cycle Detection:**
```go
// ‚úÖ GOOD: Use topo.Sort for efficient cycle detection
func HasCycles(tg *TaskGraph) (bool, error) {
    _, err := topo.Sort(tg.Graph)
    if err != nil {
        return true, nil  // Sort fails if cycles exist
    }
    return false, nil
}

// ‚úÖ GOOD: Custom cycle enumeration when needed (gonum lacks simple_cycles)
func DetectCycles(tg *TaskGraph) [][]string {
    // Use DFS to enumerate all cycles
    // Gonum provides topo.Sort but not cycle enumeration
}
```

**Critical Path Analysis:**
```go
// ‚úÖ GOOD: Use dynamic programming with topological sort
func FindCriticalPath(tg *TaskGraph) ([]string, error) {
    // Check for cycles first
    hasCycles, err := HasCycles(tg)
    if err != nil || hasCycles {
        return nil, fmt.Errorf("cannot find critical path: graph has cycles")
    }
    
    // Get topological sort
    sorted, err := TopoSortTasks(tg)
    if err != nil {
        return nil, err
    }
    
    // Dynamic programming: calculate longest path
    dist := make(map[string]int)
    prev := make(map[string]string)
    
    for _, taskID := range sorted {
        // Update distance from dependencies
        // Track path for reconstruction
    }
    
    // Reconstruct path from end to start
    return path, nil
}
```

**Dependency Level Calculation:**
```go
// ‚úÖ GOOD: Optimize with topological sort for acyclic graphs
func GetTaskLevels(tg *TaskGraph) map[string]int {
    hasCycles, _ := HasCycles(tg)
    if !hasCycles {
        // Use topological sort for O(V + E) performance
        sorted, _ := topo.Sort(tg.Graph)
        // Process in order, single pass
    } else {
        // Fallback to iterative approach for cyclic graphs
    }
}
```

**Performance Considerations:**
- **Graph Building**: O(V + E) - acceptable overhead
- **Cycle Detection**: O(V + E) - very fast with topo.Sort
- **Topological Sort**: O(V + E) - optimal algorithm
- **Critical Path**: O(V + E) - dynamic programming approach
- **GetTaskLevels**: O(V + E) for acyclic, O(V * E) worst case for cyclic
- **Memory**: ~20-30% overhead vs manual map-based graphs (acceptable trade-off)

**Testing Graph Algorithms:**
```go
// ‚úÖ GOOD: Test with various graph structures
func TestFindCriticalPath(t *testing.T) {
    tests := []struct {
        name  string
        tasks []Todo2Task
        want  []string
    }{
        {
            name:  "linear chain",
            tasks: generateTestTasks(10, 1),
            want:  []string{"T-1", "T-2", ..., "T-10"},
        },
        {
            name: "complex graph",
            tasks: generateComplexTasks(),
            want: []string{...},
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tg, _ := BuildTaskGraph(tt.tasks)
            got, err := FindCriticalPath(tg)
            // Verify correctness
        })
    }
}

// ‚úÖ GOOD: Benchmark graph operations
func BenchmarkBuildTaskGraph(b *testing.B) {
    tasks := generateTestTasks(200, 3)
    for i := 0; i < b.N; i++ {
        _, _ = BuildTaskGraph(tasks)
    }
}
```

**When NOT to Use Gonum:**
- Simple adjacency list needs (use `map[string][]string`)
- Very small graphs (< 10 nodes) where overhead isn't worth it
- Operations that don't benefit from graph algorithms

## Makefile Usage (CRITICAL)

**‚ö†Ô∏è ALWAYS USE MAKEFILE TARGETS INSTEAD OF DIRECT COMMANDS ‚ö†Ô∏è**

**Before running any command, check if a Makefile target exists. Use `make <target>` instead of generating files or running commands directly.**

### Available Makefile Targets

**Build Operations:**
- `make build` - Build the Go server (without CGO by default)
- `make go-build` - Build Go binary
- `make build-apple-fm` - Build with Apple Foundation Models support (CGO_ENABLED=1)
- `make build-swift-bridge` - Build Swift bridge for go-foundationmodels

**Development Operations:**
- `make run` - Run the MCP server (builds first)
- `make dev` - Start development mode (auto-reload on changes)
- `make dev-watch` - Watch files and auto-reload (alias for dev)
- `make dev-test` - Development mode with auto-test on changes
- `make dev-full` - Full development mode (watch + test + coverage)
- `make go-dev` - Start Go development mode (hot reload)
- `make go-dev-test` - Go dev mode with auto-test
- `make go-run` - Run Go binary

**Testing:**
- `make test` - Run all tests (Go + Python)
- `make test-go` - Run Go tests
- `make test-python` - Run Python tests (requires pytest)
- `make test-integration` - Run integration tests
- `make test-coverage` - Run tests with coverage report
- `make test-coverage-go` - Generate Go test coverage report
- `make test-coverage-python` - Generate Python test coverage report
- `make test-html` - Generate HTML coverage reports
- `make test-watch` - Run tests in watch mode
- `make test-tools` - Test Go server tools
- `make test-all` - Run all import tests + sanity check + CLI tests
- `make test-cli` - Run all CLI functionality tests
- `make go-test` - Run Go tests
- `make test-apple-fm` - Run all Apple Foundation Models tests

**Code Quality:**
- `make fmt` - Format code with exarp-go (gofmt/goimports) (requires build)
- `make lint` - Lint code with exarp-go (requires build)
- `make lint-fix` - Lint and auto-fix code with exarp-go (requires build)
- `make clean` - Clean build artifacts and cache
- `make clean-all` - Clean everything including virtual environment
- `make clean-config` - Remove configuration file

**Configuration:**
- `make config` - Configure build system (detect available tools)
- `make sanity-check` - Verify tools/resources/prompts counts match expected values

**Installation:**
- `make install` - Install Python dependencies (optional)
- `make install-dev` - Install Python development dependencies

**Benchmarking:**
- `make bench` - Run benchmarks (requires pytest)
- `make go-bench` - Run Go benchmarks

**Documentation:**
- `make docs` - Generate documentation

**Sprint Automation:**
- `make sprint-start` - Run sprint start workflow (clean backlog, align tasks)
- `make sprint-end` - Run sprint end workflow (test coverage, docs, security)
- `make pre-sprint` - Run pre-sprint cleanup (duplicates, alignment, docs)
- `make sprint` - Run full sprint automation (process all background tasks)

**Task Completion Detection:**
- `make check-tasks` - Batch check all Todo and In Progress tasks to find completed ones (dry run, no updates)
- `make update-completed-tasks` - Batch check and auto-update completed tasks (updates task status based on codebase analysis)

**Quick Commands:**
- `make all` - Build essential components and run sanity tests (default)
- `make help` - Show help message with all available targets

### Rules for AI

1. **NEVER run `go build` directly** - Use `make build` or `make go-build` instead
2. **NEVER run `go test` directly** - Use `make test`, `make test-go`, `make test-coverage`, or `make test-html` instead
3. **NEVER run linting tools directly** - Use `make lint` or `make lint-fix` instead
4. **NEVER run formatting tools directly** - Use `make fmt` instead
5. **NEVER create build scripts** - Use existing Makefile targets
6. **NEVER generate wrapper scripts** - Use `make dev`, `make go-dev`, or other dev targets
7. **ALWAYS check Makefile first** - Before suggesting any command, verify if a Makefile target exists
8. **PREFER Makefile targets** - When multiple options exist, choose the Makefile target
9. **Use `make config` first** - If tools are not detected, run `make config` to configure the build system
10. **PREFER `uv` for Python operations** - Use `uv run python` or `uvx` instead of direct `python3` commands when possible

### Examples

**‚ùå WRONG:**
```bash
go build -o bin/exarp-go ./cmd/server
go test ./...
golangci-lint run ./...
python3 -m pytest tests/
pip install package
```

**‚úÖ CORRECT:**
```bash
make build
make test
make lint
uv run pytest tests/  # or make test-python
uv sync  # or make install
```

**Python Command Guidelines:**
- **PREFER `uv`** - Use `uv run python` instead of `python3` when possible
- **PREFER `uvx`** - Use `uvx package-name` for one-off tool execution
- **PREFER `uv sync`** - Use `uv sync` instead of `pip install`
- **Fallback to python3** - Only use `python3` if `uv` is not available
- **Use Makefile targets** - Prefer `make test-python`, `make install`, etc. over direct commands

**Exception:** Only use direct commands when:
- The operation is not covered by any Makefile target
- You need to pass custom flags not supported by Makefile targets
- You're debugging a specific issue that requires direct command execution
- `uv` is not available and operation cannot use Makefile target

## AI Enforcement Checklist

**Before generating Go code, ensure:**
- ‚úÖ Follows Go naming conventions
- ‚úÖ Handles all errors explicitly
- ‚úÖ Uses context for cancellation/timeouts
- ‚úÖ Implements interfaces for testability
- ‚úÖ Includes appropriate documentation
- ‚úÖ Uses table-driven tests
- ‚úÖ Follows framework-agnostic design
- ‚úÖ Validates all inputs
- ‚úÖ Uses idiomatic Go patterns
- ‚úÖ No goroutine leaks
- ‚úÖ Proper resource cleanup
- ‚úÖ **Uses Makefile targets instead of direct commands**
- ‚úÖ **Uses gonum graph for complex graph operations** (when applicable)
- ‚úÖ **Wraps gonum graphs with domain-specific types** for metadata

**These practices are mandatory for professional Go development.**
