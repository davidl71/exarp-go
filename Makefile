.PHONY: help build build-debug build-race build-no-cgo run test test-watch test-coverage test-html clean install fmt lint dev dev-watch dev-test dev-full dev-cycle pre-push bench docs sanity-check sanity-check-cached test-cli test-cli-list test-cli-tool test-cli-test config clean-config sprint-start sprint-end pre-sprint sprint check-tasks update-completed-tasks task-sanity-check go-fmt go-vet golangci-lint-check golangci-lint-fix govulncheck check check-fix check-all build-migrate migrate migrate-dry-run install-tools go-mod-tidy go-mod-verify pre-commit ci validate check-deps test-go test-go-fast test-go-verbose test-go-parallel test-go-tools-short version scorecard scorecard-full scorecard-plans report-plan task-list task-list-todo task-list-in-progress task-list-done task-update proto proto-check proto-clean exarp-list exarp-report-scorecard exarp-report-overview exarp-health-server exarp-health-docs exarp-context-budget exarp-test

# Project configuration
PROJECT_NAME := exarp-go
BINARY_NAME := exarp-go
BINARY_PATH := bin/$(BINARY_NAME)

# Version information
VERSION := $(shell git describe --tags --always --dirty 2>/dev/null || echo "dev")
BUILD_TIME := $(shell date -u +"%Y-%m-%dT%H:%M:%SZ")
GIT_COMMIT := $(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")

# Load configuration (generated by 'make config')
-include .make.config

# Detect Go binary (check PATH first, then common locations)
GO := $(shell if command -v go >/dev/null 2>&1; then echo go; elif [ -x /usr/local/go/bin/go ]; then echo /usr/local/go/bin/go; elif [ -x $$HOME/.local/go/bin/go ]; then echo $$HOME/.local/go/bin/go; else echo go; fi)

# Colors for output
GREEN := \033[0;32m
YELLOW := \033[1;33m
RED := \033[0;31m
BLUE := \033[0;34m
NC := \033[0m # No Color

# Default target
.DEFAULT_GOAL := all

##@ Main Targets

all: build sanity-check test-tools ## Build essential components and run sanity tests
	@echo "$(GREEN)‚úÖ All essential builds and sanity checks completed successfully$(NC)"

##@ Configuration

config: ## Configure build system (detect available tools)
	@echo "$(BLUE)Configuring build system...$(NC)"
	@echo "# Auto-generated by 'make config' - DO NOT EDIT MANUALLY" > .make.config
	@echo "# Run 'make config' to regenerate" >> .make.config
	@echo "" >> .make.config
	@# Detect Go version
	@if command -v $(GO) >/dev/null 2>&1 || [ -x "$(GO)" ]; then \
		go_version=$$($(GO) version 2>/dev/null | awk '{print $$3}' | sed 's/go//'); \
		go_major=$$(echo $$go_version | cut -d. -f1); \
		go_minor=$$(echo $$go_version | cut -d. -f2); \
		if [ $$go_major -gt 1 ] || ([ $$go_major -eq 1 ] && [ $$go_minor -ge 20 ]); then \
			echo "HAVE_GO_1_20_PLUS = 1" >> .make.config; \
			echo "GO_VERSION = $$go_version" >> .make.config; \
			echo "$(GREEN)‚úÖ Found: Go $$go_version (1.20+)$(NC)"; \
		else \
			echo "HAVE_GO_1_20_PLUS = 0" >> .make.config; \
			echo "GO_VERSION = $$go_version" >> .make.config; \
			echo "$(YELLOW)‚ö†Ô∏è  Found: Go $$go_version (1.20+ required)$(NC)"; \
		fi; \
	else \
		echo "HAVE_GO_1_20_PLUS = 0" >> .make.config; \
		echo "GO_VERSION = unknown" >> .make.config; \
		echo "$(RED)‚ùå Not found: Go$(NC)"; \
	fi
	@# Detect CGO support
	@if command -v gcc >/dev/null 2>&1 || command -v clang >/dev/null 2>&1 || command -v cc >/dev/null 2>&1; then \
		echo "HAVE_CGO = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: C compiler (CGO enabled)$(NC)"; \
	else \
		echo "HAVE_CGO = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: C compiler (CGO disabled - Apple FM unavailable)$(NC)"; \
	fi
	@# Detect SQLite3
	@if command -v sqlite3 >/dev/null 2>&1; then \
		echo "HAVE_SQLITE3 = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: sqlite3$(NC)"; \
	else \
		echo "HAVE_SQLITE3 = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: sqlite3 (optional - for Todo2 database)$(NC)"; \
	fi
	@# Detect git
	@if command -v git >/dev/null 2>&1; then \
		echo "HAVE_GIT = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: git$(NC)"; \
	else \
		echo "HAVE_GIT = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: git (optional - for version info)$(NC)"; \
	fi
	@# Detect exarp-go binary
	@if [ -f $(BINARY_PATH) ]; then \
		echo "HAVE_EXARP_GO = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: exarp-go binary$(NC)"; \
	else \
		echo "HAVE_EXARP_GO = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: exarp-go binary (run 'make build' first)$(NC)"; \
	fi
	@# Detect file watchers
	@if command -v fswatch >/dev/null 2>&1 || command -v inotifywait >/dev/null 2>&1; then \
		echo "HAVE_FILE_WATCHER = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: file watcher (fswatch/inotifywait)$(NC)"; \
	else \
		echo "HAVE_FILE_WATCHER = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: file watcher (optional - dev mode will use polling)$(NC)"; \
	fi
	@echo "" >> .make.config
	@echo "$(GREEN)‚úÖ Configuration complete: .make.config$(NC)"

clean-config: ## Remove configuration file
	@rm -f .make.config
	@echo "$(GREEN)‚úÖ Configuration file removed$(NC)"

##@ Development

dev-cycle: go-fmt test-go-fast ## Quick development cycle (format, test, ready for commit)
	@echo "$(GREEN)‚úÖ Development cycle complete - ready for commit$(NC)"

pre-push: go-mod-verify check test-go-fast ## Pre-push checks (verify modules, check code, test)
	@echo "$(GREEN)‚úÖ Pre-push checks passed - safe to push$(NC)"

help: ## Show this help message
	@echo "$(BLUE)Available targets:$(NC)"
	@grep -hE '^[a-zA-Z_-]+:.*?## .*$$' Makefile | awk 'BEGIN {FS = ":.*?## "} {printf "  $(GREEN)%-20s$(NC) %s\n", $$1, $$2}'
	@if [ -f .make.config ]; then \
		echo ""; \
		echo "$(BLUE)Detected tools:$(NC)"; \
		if [ -n "$$(grep 'HAVE_GO_1_20_PLUS = 1' .make.config 2>/dev/null)" ]; then \
			go_ver=$$(grep '^GO_VERSION =' .make.config | cut -d' ' -f3); \
			echo "  $(GREEN)‚úÖ Go $$go_ver$(NC)"; \
		else \
			echo "  $(YELLOW)‚ö†Ô∏è  Go (1.20+ required)$(NC)"; \
		fi; \
		if [ -n "$$(grep 'HAVE_CGO = 1' .make.config 2>/dev/null)" ]; then \
			echo "  $(GREEN)‚úÖ CGO (Apple FM support)$(NC)"; \
		else \
			echo "  $(YELLOW)‚ö†Ô∏è  CGO (Apple FM unavailable)$(NC)"; \
		fi; \
		if [ -n "$$(grep 'HAVE_SQLITE3 = 1' .make.config 2>/dev/null)" ]; then \
			echo "  $(GREEN)‚úÖ SQLite3$(NC)"; \
		fi; \
		if [ -n "$$(grep 'HAVE_FILE_WATCHER = 1' .make.config 2>/dev/null)" ]; then \
			echo "  $(GREEN)‚úÖ File watcher$(NC)"; \
		fi; \
	else \
		echo ""; \
		echo "$(YELLOW)üí° Tip: Run 'make config' to detect available tools and optimize targets$(NC)"; \
	fi
	@echo ""
	@echo "$(BLUE)Quick start:$(NC)"
	@echo "  $(GREEN)make all$(NC)        - Build and run sanity checks (default)"
	@echo "  $(GREEN)make build$(NC)      - Build the binary"
	@echo "  $(GREEN)make test$(NC)       - Run all tests"
	@echo ""
	@echo "$(BLUE)Development workflow:$(NC)"
	@echo "  $(GREEN)make dev-cycle$(NC)  - Format, test, ready for commit"
	@echo "  $(GREEN)make pre-push$(NC)   - Run before git push"

build: ## Build the Go server (CGO enabled on Mac Silicon by default, disabled elsewhere)
	@echo "$(BLUE)Building $(PROJECT_NAME) v$(VERSION)...$(NC)"
	@if ! command -v $(GO) >/dev/null 2>&1 && [ ! -x "$(GO)" ]; then \
		echo "$(RED)‚ùå Go not found. Install Go or set PATH to include Go bin directory$(NC)"; \
		exit 1; \
	fi
	@# Detect Mac Silicon (Darwin + arm64) - use CGO for Apple Foundation Models
	@if [ "$$(uname -s)" = "Darwin" ] && [ "$$(uname -m)" = "arm64" ]; then \
		if command -v gcc >/dev/null 2>&1 || command -v clang >/dev/null 2>&1 || command -v cc >/dev/null 2>&1; then \
			echo "$(BLUE)Detected Mac Silicon - Building with CGO (Apple Foundation Models support)$(NC)"; \
			CGO_ENABLED=1 $(GO) build -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)" -o $(BINARY_PATH) ./cmd/server 2>&1 || (echo "$(YELLOW)‚ö†Ô∏è  CGO build failed - falling back to build without CGO$(NC)" && CGO_ENABLED=0 $(GO) build -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)" -o $(BINARY_PATH) ./cmd/server || (echo "$(RED)‚ùå Build failed$(NC)" && exit 1)); \
			echo "$(GREEN)‚úÖ Server built: $(BINARY_PATH) (v$(VERSION))$(NC)"; \
		else \
			echo "$(YELLOW)‚ö†Ô∏è  Mac Silicon detected but C compiler not found - Building without CGO$(NC)"; \
			echo "$(YELLOW)   Install Xcode Command Line Tools: xcode-select --install$(NC)"; \
			CGO_ENABLED=0 $(GO) build -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)" -o $(BINARY_PATH) ./cmd/server || (echo "$(RED)‚ùå Build failed$(NC)" && exit 1); \
			echo "$(GREEN)‚úÖ Server built: $(BINARY_PATH) (v$(VERSION))$(NC)"; \
		fi; \
	else \
		echo "$(BLUE)Building without CGO for portability (static binary, cross-platform)$(NC)"; \
		CGO_ENABLED=0 $(GO) build -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)" -o $(BINARY_PATH) ./cmd/server || (echo "$(RED)‚ùå Build failed$(NC)" && exit 1); \
		echo "$(GREEN)‚úÖ Server built: $(BINARY_PATH) (v$(VERSION))$(NC)"; \
	fi

build-debug: ## Build with debug symbols (for debugging)
	@echo "$(BLUE)Building $(PROJECT_NAME) v$(VERSION) with debug symbols...$(NC)"
	@if ! command -v $(GO) >/dev/null 2>&1 && [ ! -x "$(GO)" ]; then \
		echo "$(RED)‚ùå Go not found. Install Go or set PATH to include Go bin directory$(NC)"; \
		exit 1; \
	fi
	@# Detect Mac Silicon (Darwin + arm64) - enable CGO if available
	@if [ "$$(uname -s)" = "Darwin" ] && [ "$$(uname -m)" = "arm64" ]; then \
		if command -v gcc >/dev/null 2>&1 || command -v clang >/dev/null 2>&1 || command -v cc >/dev/null 2>&1; then \
			CGO_ENABLED=1 $(GO) build -gcflags="all=-N -l" -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)" -o $(BINARY_PATH) ./cmd/server || (echo "$(RED)‚ùå Debug build failed$(NC)" && exit 1); \
		else \
			CGO_ENABLED=0 $(GO) build -gcflags="all=-N -l" -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)" -o $(BINARY_PATH) ./cmd/server || (echo "$(RED)‚ùå Debug build failed$(NC)" && exit 1); \
		fi; \
	else \
		CGO_ENABLED=0 $(GO) build -gcflags="all=-N -l" -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)" -o $(BINARY_PATH) ./cmd/server || (echo "$(RED)‚ùå Debug build failed$(NC)" && exit 1); \
	fi
	@echo "$(GREEN)‚úÖ Debug build complete: $(BINARY_PATH) (v$(VERSION))$(NC)"

build-race: ## Build with race detector (for detecting race conditions)
	@echo "$(BLUE)Building $(PROJECT_NAME) v$(VERSION) with race detector...$(NC)"
	@if ! command -v $(GO) >/dev/null 2>&1 && [ ! -x "$(GO)" ]; then \
		echo "$(RED)‚ùå Go not found. Install Go or set PATH to include Go bin directory$(NC)"; \
		exit 1; \
	fi
	@echo "$(YELLOW)Note: Race detector adds overhead - use for testing only$(NC)"
	@# Detect Mac Silicon (Darwin + arm64) - enable CGO if available
	@if [ "$$(uname -s)" = "Darwin" ] && [ "$$(uname -m)" = "arm64" ]; then \
		if command -v gcc >/dev/null 2>&1 || command -v clang >/dev/null 2>&1 || command -v cc >/dev/null 2>&1; then \
			CGO_ENABLED=1 $(GO) build -race -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)" -o $(BINARY_PATH) ./cmd/server || (echo "$(RED)‚ùå Race build failed$(NC)" && exit 1); \
		else \
			CGO_ENABLED=0 $(GO) build -race -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)" -o $(BINARY_PATH) ./cmd/server || (echo "$(RED)‚ùå Race build failed$(NC)" && exit 1); \
		fi; \
	else \
		CGO_ENABLED=0 $(GO) build -race -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)" -o $(BINARY_PATH) ./cmd/server || (echo "$(RED)‚ùå Race build failed$(NC)" && exit 1); \
	fi
	@echo "$(GREEN)‚úÖ Race detector build complete: $(BINARY_PATH) (v$(VERSION))$(NC)"

build-migrate: ## Build JSON to SQLite migration tool
	@echo "$(BLUE)Building migration tool...$(NC)"
	@if ! command -v $(GO) >/dev/null 2>&1 && [ ! -x "$(GO)" ]; then \
		echo "$(RED)‚ùå Go not found. Install Go or set PATH to include Go bin directory$(NC)"; \
		exit 1; \
	fi
	@CGO_ENABLED=1 $(GO) build -o bin/migrate ./cmd/migrate || (echo "$(RED)‚ùå Migration tool build failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Migration tool built: bin/migrate$(NC)"

run: build ## Run the MCP server
	@echo "$(BLUE)Running $(PROJECT_NAME) server...$(NC)"
	@$(BINARY_PATH)

dev: ## Start development mode (auto-reload on changes)
	@echo "$(BLUE)Starting development mode...$(NC)"
	@./dev.sh --watch

dev-watch: ## Watch files and auto-reload (alias for dev)
	@$(MAKE) dev

dev-test: ## Development mode with auto-test on changes
	@echo "$(BLUE)Starting development mode with auto-test...$(NC)"
	@./dev.sh --watch --test

dev-full: ## Full development mode (watch + test + coverage)
	@echo "$(BLUE)Starting full development mode...$(NC)"
	@./dev.sh --watch --test --coverage

##@ Testing

test: test-go ## Run all tests (Go only)
	@echo "$(GREEN)‚úÖ All tests passed$(NC)"

test-go: ## Run Go tests (optimized for speed with parallel execution, CGO disabled)
	@echo "$(BLUE)Running Go tests (parallel, CGO_ENABLED=0)...$(NC)"
	@CGO_ENABLED=0 $(GO) test ./... -parallel 4 || \
	 (echo "$(RED)‚ùå Go tests failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Go tests passed$(NC)"

test-go-fast: ## Run Go tests in parallel (fast, no verbose, CGO disabled) - optimized for pre-push
	@echo "$(BLUE)Running Go tests (parallel, fast, CGO_ENABLED=0)...$(NC)"
	@CGO_ENABLED=0 $(GO) test ./... -parallel 4 || \
	 (echo "$(RED)‚ùå Parallel tests failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Go tests passed$(NC)"

test-go-verbose: ## Run Go tests with verbose output (CGO disabled)
	@echo "$(BLUE)Running Go tests (verbose, CGO_ENABLED=0)...$(NC)"
	@CGO_ENABLED=0 $(GO) test ./... -v || \
	 (echo "$(YELLOW)‚ö†Ô∏è  Go tests failed or not available$(NC)"

test-go-parallel: ## Run Go tests in parallel (faster, CGO disabled)
	@echo "$(BLUE)Running Go tests in parallel (CGO_ENABLED=0)...$(NC)"
	@CGO_ENABLED=0 $(GO) test ./... -v -parallel 4 || \
	 (echo "$(RED)‚ùå Parallel tests failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Parallel tests passed$(NC)"

test-go-tools-short: ## Run internal/tools tests with -short (skips discover/sprint; use when CGO=1 for fast feedback)
	@echo "$(BLUE)Running tools tests (short mode, skips long-running discover/sprint)...$(NC)"
	@$(GO) test ./internal/tools -short -timeout=60s -count=1 || \
	 (echo "$(RED)‚ùå Tools tests failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Tools tests passed (short)$(NC)"

test-integration: ## Run Go tests (Python integration tests removed)
	@echo "$(BLUE)Running Go tests...$(NC)"
	@$(GO) test ./... -v || echo "$(YELLOW)‚ö†Ô∏è  Go tests failed$(NC)"

test-coverage: test-coverage-go ## Run tests with coverage (Go only)

test-coverage-go: ## Generate Go test coverage report
	@echo "$(BLUE)Running Go tests with coverage...$(NC)"
	@$(GO) test ./... -coverprofile=coverage-go.out -covermode=atomic || \
	 echo "$(YELLOW)‚ö†Ô∏è  Go coverage failed$(NC)"
	@$(GO) tool cover -html=coverage-go.out -o coverage-go.html 2>/dev/null || true
	@echo "$(GREEN)‚úÖ Go coverage report: coverage-go.html$(NC)"

test-html: test-coverage ## Generate HTML coverage reports (alias for test-coverage)

test-watch: ## Run tests in watch mode (auto-test on changes)
	@echo "$(BLUE)Starting test watch mode...$(NC)"
	@./dev.sh --test-watch

test-tools: build ## Test Go server tools
	@echo "$(BLUE)Testing Go server...$(NC)"
	@test -f $(BINARY_PATH) && echo "$(GREEN)‚úÖ Go binary exists$(NC)" || (echo "$(RED)‚ùå Go binary not found$(NC)" && exit 1)
	@test -x $(BINARY_PATH) && echo "$(GREEN)‚úÖ Go binary is executable$(NC)" || (echo "$(RED)‚ùå Go binary is not executable$(NC)" && exit 1)

sanity-check: ## Verify tools/resources/prompts counts match expected values
	@echo "$(BLUE)Running sanity check...$(NC)"
	@$(GO) build -o bin/sanity-check cmd/sanity-check/main.go 2>/dev/null || true
	@./bin/sanity-check || (echo "$(RED)‚ùå Sanity check failed$(NC)" && exit 1)

sanity-check-cached: bin/sanity-check ## Verify tools/resources/prompts counts (cached binary)
	@echo "$(BLUE)Running sanity check (cached)...$(NC)"
	@./bin/sanity-check || (echo "$(RED)‚ùå Sanity check failed$(NC)" && exit 1)

# Build sanity-check binary only if source changed (caching optimization)
bin/sanity-check: cmd/sanity-check/main.go
	@echo "$(BLUE)Building sanity-check binary...$(NC)"
	@$(GO) build -o bin/sanity-check cmd/sanity-check/main.go 2>/dev/null || true

test-all: test-tools sanity-check test-cli ## Run all import tests + sanity check + CLI tests

test-mcp: ## Test MCP server via stdio (requires manual input)
	@echo "$(BLUE)Testing MCP server (stdio mode)...$(NC)"
	@echo "$(YELLOW)Note: This requires manual JSON-RPC input$(NC)"
	@$(BINARY_PATH) < /dev/stdin

##@ CLI Testing

test-cli: build test-cli-list test-cli-tool test-cli-test ## Run all CLI functionality tests
	@echo "$(GREEN)‚úÖ All CLI tests passed$(NC)"

test-cli-list: build ## Test CLI list tools functionality
	@echo "$(BLUE)Testing CLI: list tools...$(NC)"
	@$(BINARY_PATH) -list > /dev/null 2>&1 && \
	 echo "$(GREEN)‚úÖ CLI list command works$(NC)" || \
	 (echo "$(RED)‚ùå CLI list command failed$(NC)" && exit 1)

test-cli-tool: build ## Test CLI tool execution
	@echo "$(BLUE)Testing CLI: tool execution...$(NC)"
	@$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"go-vet","path":"cmd/server"}' > /dev/null 2>&1 && \
	 echo "$(GREEN)‚úÖ CLI tool execution works$(NC)" || \
	 (echo "$(YELLOW)‚ö†Ô∏è  CLI tool execution test skipped (may require valid tool/args)$(NC)")

test-cli-test: build ## Test CLI feature testing mode
	@echo "$(BLUE)Testing CLI: feature testing mode...$(NC)"
	@$(BINARY_PATH) -test lint > /dev/null 2>&1 && \
	 echo "$(GREEN)‚úÖ CLI test mode works$(NC)" || \
	 (echo "$(YELLOW)‚ö†Ô∏è  CLI test mode skipped (may require valid tool)$(NC)")

test-cli-help: build ## Test CLI help/usage display
	@echo "$(BLUE)Testing CLI: help display...$(NC)"
	@$(BINARY_PATH) 2>&1 | grep -qE "(Usage|exarp-go)" && \
	 echo "$(GREEN)‚úÖ CLI help display works$(NC)" || \
	 (echo "$(YELLOW)‚ö†Ô∏è  CLI help display test inconclusive$(NC)")

test-cli-mode: build ## Test CLI mode detection (TTY vs stdio)
	@echo "$(BLUE)Testing CLI: mode detection...$(NC)"
	@echo "$(BLUE)  Testing TTY mode (should show CLI)...$(NC)"
	@$(BINARY_PATH) -list > /dev/null 2>&1 && \
	 echo "$(GREEN)  ‚úÖ TTY mode detected correctly$(NC)" || \
	 echo "$(YELLOW)  ‚ö†Ô∏è  TTY mode test inconclusive$(NC)"
	@echo "$(BLUE)  Testing stdio mode (should run as MCP server)...$(NC)"
	@echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}' | timeout 2 $(BINARY_PATH) 2>&1 | grep -q "jsonrpc" && \
	 echo "$(GREEN)  ‚úÖ Stdio mode detected correctly$(NC)" || \
	 echo "$(YELLOW)  ‚ö†Ô∏è  Stdio mode test inconclusive (may timeout)$(NC)"

##@ Code Quality

# Direct Go tool targets (faster, no binary required)
go-fmt: ## Format Go code with gofmt
	@echo "$(BLUE)Formatting Go code with gofmt...$(NC)"
	@$(GO) fmt ./... || (echo "$(RED)‚ùå go fmt failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Go code formatted$(NC)"

go-vet: ## Check Go code with go vet
	@echo "$(BLUE)Checking Go code with go vet...$(NC)"
	@$(GO) vet ./... || (echo "$(RED)‚ùå go vet found issues$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ go vet passed$(NC)"

golangci-lint-check: ## Check code with golangci-lint
	@echo "$(BLUE)Checking code with golangci-lint...$(NC)"
	@if command -v golangci-lint >/dev/null 2>&1; then \
		golangci-lint run --timeout 5m ./... || (echo "$(RED)‚ùå golangci-lint found issues$(NC)" && exit 1); \
		echo "$(GREEN)‚úÖ golangci-lint passed$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  golangci-lint not found$(NC)"; \
		echo "$(YELLOW)   Install: go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest$(NC)"; \
		exit 1; \
	fi

golangci-lint-fix: ## Fix code with golangci-lint (auto-fix)
	@echo "$(BLUE)Fixing code with golangci-lint...$(NC)"
	@if command -v golangci-lint >/dev/null 2>&1; then \
		golangci-lint run --timeout 5m --fix ./... || (echo "$(YELLOW)‚ö†Ô∏è  Some issues could not be auto-fixed$(NC)"); \
		echo "$(GREEN)‚úÖ golangci-lint fixes applied$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  golangci-lint not found$(NC)"; \
		echo "$(YELLOW)   Install: go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest$(NC)"; \
		exit 1; \
	fi

govulncheck: ## Check for vulnerabilities with govulncheck
	@echo "$(BLUE)Checking for vulnerabilities with govulncheck...$(NC)"
	@if command -v govulncheck >/dev/null 2>&1 || [ -x "$$HOME/go/bin/govulncheck" ]; then \
		if command -v govulncheck >/dev/null 2>&1; then \
			govulncheck ./... || (echo "$(RED)‚ùå Vulnerabilities found$(NC)" && exit 1); \
		else \
			$$HOME/go/bin/govulncheck ./... || (echo "$(RED)‚ùå Vulnerabilities found$(NC)" && exit 1); \
		fi; \
		echo "$(GREEN)‚úÖ No vulnerabilities found$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  govulncheck not found$(NC)"; \
		echo "$(YELLOW)   Install: go install golang.org/x/vuln/cmd/govulncheck@latest$(NC)"; \
		exit 1; \
	fi

check: go-fmt go-vet golangci-lint-check ## Check code quality (fmt + vet + lint)
	@echo "$(GREEN)‚úÖ All code quality checks passed$(NC)"

check-fix: go-fmt golangci-lint-fix ## Check and auto-fix code (fmt + lint-fix)
	@echo "$(GREEN)‚úÖ Code checked and fixed$(NC)"

check-all: check govulncheck ## Run all checks including security (fmt + vet + lint + vulncheck)
	@echo "$(GREEN)‚úÖ All checks passed (including security)$(NC)"

# Legacy targets (using exarp-go binary)
fmt: ## Format code with exarp-go (gofmt/goimports) (requires build)
	@if [ -f $(BINARY_PATH) ]; then \
		echo "$(BLUE)Formatting code...$(NC)"; \
		$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"gofmt","path":".","fix":true}' 2>/dev/null || \
			echo "$(YELLOW)exarp-go format tool completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Code formatted$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		echo "$(BLUE)Formatting code...$(NC)"; \
		$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"gofmt","path":".","fix":true}' 2>/dev/null || \
			echo "$(YELLOW)exarp-go format tool completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Code formatted$(NC)"; \
	fi

lint: ## Lint code with exarp-go (requires build)
	@if [ -f $(BINARY_PATH) ]; then \
		echo "$(BLUE)Linting code...$(NC)"; \
		$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"auto","path":"."}' 2>/dev/null || \
			echo "$(YELLOW)exarp-go lint tool completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Linting complete$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		echo "$(BLUE)Linting code...$(NC)"; \
		$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"auto","path":"."}' 2>/dev/null || \
			echo "$(YELLOW)exarp-go lint tool completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Linting complete$(NC)"; \
	fi

lint-fix: ## Lint and auto-fix code with exarp-go (requires build)
	@if [ -f $(BINARY_PATH) ]; then \
		echo "$(BLUE)Linting and fixing code...$(NC)"; \
		$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"auto","path":".","fix":true}' 2>/dev/null || \
			echo "$(YELLOW)exarp-go lint-fix tool completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Linting and fixes complete$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		echo "$(BLUE)Linting and fixing code...$(NC)"; \
		$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"auto","path":".","fix":true}' 2>/dev/null || \
			echo "$(YELLOW)exarp-go lint-fix tool completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Linting and fixes complete$(NC)"; \
	fi

##@ Benchmarking

bench: go-bench ## Run Go benchmarks (Python benchmarks removed; use 'make go-bench')

##@ Documentation

docs: ## Generate documentation
	@echo "$(BLUE)Generating documentation...$(NC)"
	@echo "$(YELLOW)Documentation generation not available for Go server$(NC)"

scorecard: ## Generate project scorecard (fast mode - default)
	@echo "$(BLUE)Generating project scorecard (fast mode)...$(NC)"
	@$(GO) run ./cmd/scorecard

scorecard-full: ## Generate project scorecard (full mode - all checks)
	@echo "$(BLUE)Generating project scorecard (full mode - this may take longer)...$(NC)"
	@$(GO) run ./cmd/scorecard --full

scorecard-plans: build ## Create improvement plans per scorecard dimension (testing, security, docs, completion)
	@echo "$(BLUE)Creating scorecard improvement plans in .cursor/plans/...$(NC)"
	@PROJECT_ROOT="$(CURDIR)" $(BINARY_PATH) -tool report -args '{"action":"scorecard_plans"}' </dev/null

report-plan: build ## Generate Cursor-style plan (.cursor/plans/<project>.plan.md). Use local binary; avoids bridge path errors.
	@echo "$(BLUE)Generating plan in .cursor/plans/...$(NC)"
	@PROJECT_ROOT="$(CURDIR)" $(BINARY_PATH) -tool report -args '{"action":"plan"}'

##@ Cleanup

clean: ## Clean build artifacts and cache
	@echo "$(BLUE)Cleaning...$(NC)"
	@rm -rf __pycache__ .pytest_cache .coverage htmlcov/
	@rm -f coverage-go.out coverage-go.html
	@rm -f bin/sanity-check bin/migrate
	@find . -type d -name __pycache__ -exec rm -r {} + 2>/dev/null || true
	@find . -type f -name "*.pyc" -delete 2>/dev/null || true
	@echo "$(GREEN)‚úÖ Clean complete$(NC)"

clean-all: clean ## Clean everything including virtual environment
	@echo "$(BLUE)Cleaning everything...$(NC)"
	@rm -rf .venv/ uv.lock
	@echo "$(GREEN)‚úÖ Full clean complete$(NC)"

##@ Installation

install-binary: build ## Install exarp-go binary to GOPATH/bin (adds to PATH)
	@echo "$(BLUE)Installing exarp-go binary...$(NC)"
	@if [ ! -f "$(BINARY_PATH)" ]; then \
		echo "$(RED)‚ùå Binary not found: $(BINARY_PATH)$(NC)"; \
		echo "$(YELLOW)Run 'make build' first$(NC)"; \
		exit 1; \
	fi
	@GOPATH_BIN=$$($(GO) env GOPATH)/bin; \
	if [ -z "$$GOPATH_BIN" ] || [ "$$GOPATH_BIN" = "/bin" ]; then \
		echo "$(RED)‚ùå Invalid GOPATH/bin: $$GOPATH_BIN$(NC)"; \
		exit 1; \
	fi; \
	mkdir -p "$$GOPATH_BIN"; \
	cp "$(BINARY_PATH)" "$$GOPATH_BIN/$(BINARY_NAME)"; \
	chmod +x "$$GOPATH_BIN/$(BINARY_NAME)"; \
	echo "$(GREEN)‚úÖ Installed to: $$GOPATH_BIN/$(BINARY_NAME)$(NC)"; \
	if ! echo "$$PATH" | grep -q "$$GOPATH_BIN"; then \
		echo "$(YELLOW)‚ö†Ô∏è  Warning: $$GOPATH_BIN is not in PATH$(NC)"; \
		echo "$(YELLOW)   Add to ~/.zshrc or ~/.bashrc: export PATH=\"$$GOPATH_BIN:\$$PATH\"$(NC)"; \
	fi

install: install-binary ## Install exarp-go binary (no Python dependencies)

install-dev: install ## Alias for install (no Python dev deps)

##@ Go Development

go-build: ## Build Go binary (CGO enabled on Mac Silicon by default)
	@echo "$(BLUE)Building Go binary...$(NC)"
	@if ! command -v $(GO) >/dev/null 2>&1 && [ ! -x "$(GO)" ]; then \
		echo "$(RED)‚ùå Go not found. Install Go or set PATH to include Go bin directory$(NC)"; \
		exit 1; \
	fi
	@# Detect Mac Silicon (Darwin + arm64) - enable CGO if available
	@if [ "$$(uname -s)" = "Darwin" ] && [ "$$(uname -m)" = "arm64" ]; then \
		if command -v gcc >/dev/null 2>&1 || command -v clang >/dev/null 2>&1 || command -v cc >/dev/null 2>&1; then \
			CGO_ENABLED=1 $(GO) build -o $(BINARY_PATH) ./cmd/server || \
			 (echo "$(RED)‚ùå Build failed$(NC)" && exit 1); \
		else \
			CGO_ENABLED=0 $(GO) build -o $(BINARY_PATH) ./cmd/server || \
			 (echo "$(RED)‚ùå Build failed$(NC)" && exit 1); \
		fi; \
	else \
		CGO_ENABLED=0 $(GO) build -o $(BINARY_PATH) ./cmd/server || \
		 (echo "$(RED)‚ùå Build failed$(NC)" && exit 1); \
	fi
	@chmod +x $(BINARY_PATH)
	@echo "$(GREEN)‚úÖ Build complete: $(BINARY_PATH)$(NC)"

go-run: go-build ## Run Go binary
	@echo "$(BLUE)Running $(BINARY_NAME)...$(NC)"
	@$(BINARY_PATH)

go-dev: ## Start Go development mode (hot reload)
	@echo "$(BLUE)Starting Go development mode...$(NC)"
	@./dev-go.sh --watch

go-dev-test: ## Go dev mode with auto-test
	@echo "$(BLUE)Starting Go development mode with auto-test...$(NC)"
	@./dev-go.sh --watch --test

go-test: ## Run Go tests
	@echo "$(BLUE)Running Go tests...$(NC)"
	@$(GO) test ./... -v || \
	 (echo "$(RED)‚ùå Tests failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ All tests passed$(NC)"

go-bench: ## Run Go benchmarks (without CGO to avoid Apple FM dependencies)
	@echo "$(BLUE)Running Go benchmarks (CGO_ENABLED=0)...$(NC)"
	@CGO_ENABLED=0 $(GO) test -bench=. -benchmem -benchtime=3s ./internal/tools/... || \
	 echo "$(YELLOW)‚ö†Ô∏è  Go benchmarks failed$(NC)"

##@ Apple Foundation Models

# CGO availability detection
# Checks if CGO can be enabled (requires C compiler)
CGO_AVAILABLE := $(shell \
	if command -v gcc >/dev/null 2>&1 || command -v clang >/dev/null 2>&1 || command -v cc >/dev/null 2>&1; then \
		echo "1"; \
	else \
		echo "0"; \
	fi \
)

# Platform detection for Swift bridge support
# Checks: macOS (Darwin) + arm64 architecture + Swift compiler available
SWIFT_BRIDGE_SUPPORTED := $(shell \
	if [ "$$(uname -s)" = "Darwin" ] && [ "$$(uname -m)" = "arm64" ]; then \
		if command -v swiftc >/dev/null 2>&1 && command -v xcrun >/dev/null 2>&1; then \
			echo "1"; \
		else \
			echo "0"; \
		fi; \
	else \
		echo "0"; \
	fi \
)

build-no-cgo: ## Build without CGO (explicitly disable CGO even on Mac Silicon)
	@echo "$(BLUE)Building $(PROJECT_NAME) v$(VERSION) without CGO...$(NC)"
	@if ! command -v $(GO) >/dev/null 2>&1 && [ ! -x "$(GO)" ]; then \
		echo "$(RED)‚ùå Go not found. Install Go or set PATH to include Go bin directory$(NC)"; \
		exit 1; \
	fi
	@echo "$(YELLOW)Note: Building without CGO (static binary, cross-platform)$(NC)"
	@CGO_ENABLED=0 $(GO) build -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)" -o $(BINARY_PATH) ./cmd/server || (echo "$(RED)‚ùå Build failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Server built: $(BINARY_PATH) (v$(VERSION))$(NC)"

build-apple-fm: build-swift-bridge ## Build with Apple Foundation Models support (CGO_ENABLED=1, full Swift bridge)
	@if [ "$(CGO_AVAILABLE)" != "1" ]; then \
		echo "$(RED)‚ùå CGO is not available - required for Apple Foundation Models$(NC)"; \
		echo "$(YELLOW)   Reason: C compiler not found (gcc, clang, or cc)$(NC)"; \
		echo "$(YELLOW)   Solution: Install a C compiler to enable CGO$(NC)"; \
		echo "$(YELLOW)   - macOS: Install Xcode Command Line Tools: xcode-select --install$(NC)"; \
		echo "$(YELLOW)   - Linux: Install gcc: sudo apt-get install gcc (Debian/Ubuntu) or sudo yum install gcc (RHEL/CentOS)$(NC)"; \
		echo "$(YELLOW)   - Or use 'make build' for a build without Apple FM support$(NC)"; \
		exit 1; \
	fi
	@echo "$(BLUE)Building with Apple Foundation Models support...$(NC)"
	@if [ -d "vendor" ]; then \
		echo "$(BLUE)Using vendor directory for build...$(NC)"; \
		CGO_ENABLED=1 go build -mod=vendor -o $(BINARY_PATH) ./cmd/server 2>&1 | grep -v "ld: warning:" || true; \
		if [ -f "$(BINARY_PATH)" ]; then \
			echo "$(GREEN)‚úÖ Server built with Apple FM support: $(BINARY_PATH)$(NC)"; \
		else \
			echo "$(YELLOW)‚ö†Ô∏è  Build with Apple FM failed - Swift bridge may not be available$(NC)"; \
			echo "$(YELLOW)   Building without Apple FM support (CGO disabled)$(NC)"; \
			CGO_ENABLED=0 go build -mod=vendor -o $(BINARY_PATH) ./cmd/server || \
			 (echo "$(RED)‚ùå Build failed$(NC)" && exit 1); \
			echo "$(GREEN)‚úÖ Server built without Apple FM support: $(BINARY_PATH)$(NC)"; \
			echo "$(YELLOW)   Note: Apple Foundation Models tool will not be available$(NC)"; \
		fi; \
	else \
		CGO_ENABLED=1 go build -o $(BINARY_PATH) ./cmd/server 2>&1 | grep -v "ld: warning:" || true; \
		if [ -f "$(BINARY_PATH)" ]; then \
			echo "$(GREEN)‚úÖ Server built with Apple FM support: $(BINARY_PATH)$(NC)"; \
		else \
			echo "$(YELLOW)‚ö†Ô∏è  Build with Apple FM failed - Swift bridge may not be available$(NC)"; \
			echo "$(YELLOW)   Building without Apple FM support (CGO disabled)$(NC)"; \
			CGO_ENABLED=0 go build -o $(BINARY_PATH) ./cmd/server || \
			 (echo "$(RED)‚ùå Build failed$(NC)" && exit 1); \
			echo "$(GREEN)‚úÖ Server built without Apple FM support: $(BINARY_PATH)$(NC)"; \
			echo "$(YELLOW)   Note: Apple Foundation Models tool will not be available$(NC)"; \
		fi; \
	fi

build-swift-bridge: ## Build Swift bridge in go-foundationmodels package (auto-detects platform support)
	@if [ "$(SWIFT_BRIDGE_SUPPORTED)" != "1" ]; then \
		echo "$(YELLOW)‚ö†Ô∏è  Swift bridge not supported on this platform$(NC)"; \
		if [ "$$(uname -s)" != "Darwin" ]; then \
			echo "$(YELLOW)   Reason: Not macOS (current OS: $$(uname -s))$(NC)"; \
		elif [ "$$(uname -m)" != "arm64" ]; then \
			echo "$(YELLOW)   Reason: Not Apple Silicon (current arch: $$(uname -m))$(NC)"; \
		elif ! command -v swiftc >/dev/null 2>&1; then \
			echo "$(YELLOW)   Reason: Swift compiler not found (install Xcode)$(NC)"; \
		elif ! command -v xcrun >/dev/null 2>&1; then \
			echo "$(YELLOW)   Reason: xcrun not found (install Xcode)$(NC)"; \
		fi; \
		echo "$(YELLOW)   Skipping Swift bridge build$(NC)"; \
		exit 0; \
	fi
	@echo "$(BLUE)Building Swift bridge for go-foundationmodels...$(NC)"
	@echo "$(YELLOW)Note: Module cache is read-only, using vendor directory...$(NC)"
	@if [ ! -d "vendor" ]; then \
		echo "$(BLUE)Creating vendor directory...$(NC)"; \
		go mod vendor; \
	fi
	@if [ -d "vendor/github.com/blacktop/go-foundationmodels" ]; then \
		cd vendor/github.com/blacktop/go-foundationmodels && \
		if [ -f "libFMShim.a" ]; then \
			echo "$(GREEN)‚úÖ Swift bridge already built$(NC)"; \
		else \
			echo "$(BLUE)Compiling Swift bridge...$(NC)"; \
			if swiftc -sdk $$(xcrun --show-sdk-path) -target arm64-apple-macos26 -emit-object -parse-as-library -whole-module-optimization -O -o libFMShim.o FoundationModelsShim.swift 2>/dev/null && \
			   ar rcs libFMShim.a libFMShim.o && \
			   rm -f libFMShim.o; then \
				echo "$(GREEN)‚úÖ Swift bridge built in vendor directory$(NC)"; \
			else \
				echo "$(YELLOW)‚ö†Ô∏è  Swift bridge build failed - Apple FM will not be available$(NC)"; \
				echo "$(YELLOW)   This is non-fatal - build will continue without Apple FM support$(NC)"; \
			fi; \
		fi; \
	elif [ -d "$$(go list -m -f '{{.Dir}}' github.com/blacktop/go-foundationmodels@v0.1.8 2>/dev/null)" ]; then \
		echo "$(YELLOW)‚ö†Ô∏è  Vendor directory not found, trying module cache (may fail)...$(NC)"; \
		cd $$(go list -m -f '{{.Dir}}' github.com/blacktop/go-foundationmodels@v0.1.8) && \
		if swiftc -sdk $$(xcrun --show-sdk-path) -target arm64-apple-macos26 -emit-object -parse-as-library -whole-module-optimization -O -o libFMShim.o FoundationModelsShim.swift 2>/dev/null && \
		   ar rcs libFMShim.a libFMShim.o && \
		   rm -f libFMShim.o; then \
			echo "$(GREEN)‚úÖ Swift bridge built$(NC)"; \
		else \
			echo "$(YELLOW)‚ö†Ô∏è  Swift bridge build failed - Apple FM will not be available$(NC)"; \
			echo "$(YELLOW)   This is non-fatal - build will continue without Apple FM support$(NC)"; \
		fi; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  go-foundationmodels package not found$(NC)"; \
		echo "$(YELLOW)   Swift bridge cannot be built - Apple FM will not be available$(NC)"; \
		echo "$(YELLOW)   This is non-fatal - build will continue without Apple FM support$(NC)"; \
		echo "$(YELLOW)   Try running: go mod vendor$(NC)"; \
	fi

test-apple-fm: test-apple-fm-unit test-apple-fm-integration ## Run all Apple Foundation Models tests

test-apple-fm-unit: ## Run Apple Foundation Models unit tests (no Swift bridge required)
	@echo "$(BLUE)Running Apple FM unit tests...$(NC)"
	@go test ./internal/tools/apple_foundation_helpers_test.go ./internal/tools/apple_foundation_helpers.go -v || \
	 echo "$(YELLOW)‚ö†Ô∏è  Unit tests failed or skipped$(NC)"

test-apple-fm-integration: build-apple-fm ## Run Apple Foundation Models integration tests (requires Swift bridge)
	@echo "$(BLUE)Running Apple FM integration tests...$(NC)"
	@echo "$(YELLOW)Note: Requires Swift bridge to be built$(NC)"
	@CGO_ENABLED=1 go test ./internal/tools -run TestHandleAppleFoundationModels -v || \
	 echo "$(YELLOW)‚ö†Ô∏è  Integration tests failed (may need Swift bridge)$(NC)"

##@ Sprint Automation

sprint-start: ## Run sprint start workflow (clean backlog, align tasks)
	@echo "$(BLUE)Running sprint start workflow...$(NC)"
	@if [ -f $(BINARY_PATH) ]; then \
		$(BINARY_PATH) -tool automation -args '{"action":"sprint","run_analysis_tools":true,"run_testing_tools":false,"extract_subtasks":true,"auto_approve":true,"max_iterations":1}' || \
		echo "$(YELLOW)‚ö†Ô∏è  Sprint start workflow completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Sprint start workflow complete$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		$(BINARY_PATH) -tool automation -args '{"action":"sprint","run_analysis_tools":true,"run_testing_tools":false,"extract_subtasks":true,"auto_approve":true,"max_iterations":1}' || \
		echo "$(YELLOW)‚ö†Ô∏è  Sprint start workflow completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Sprint start workflow complete$(NC)"; \
	fi

sprint-end: ## Run sprint end workflow (test coverage, docs, security)
	@echo "$(BLUE)Running sprint end workflow...$(NC)"
	@if [ -f $(BINARY_PATH) ]; then \
		$(MAKE) test-coverage; \
		$(BINARY_PATH) -tool health -args '{"action":"docs"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Docs health check completed$(NC)"; \
		$(BINARY_PATH) -tool security -args '{"action":"report"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Security check completed$(NC)"; \
		echo "$(GREEN)‚úÖ Sprint end workflow complete$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		$(MAKE) test-coverage; \
		$(BINARY_PATH) -tool health -args '{"action":"docs"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Docs health check completed$(NC)"; \
		$(BINARY_PATH) -tool security -args '{"action":"report"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Security check completed$(NC)"; \
		echo "$(GREEN)‚úÖ Sprint end workflow complete$(NC)"; \
	fi

pre-sprint: ## Run pre-sprint cleanup (duplicates, alignment, docs)
	@echo "$(BLUE)Running pre-sprint cleanup...$(NC)"
	@if [ -f $(BINARY_PATH) ]; then \
		$(BINARY_PATH) -tool task_analysis -args '{"action":"duplicates"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Duplicate detection completed$(NC)"; \
		$(BINARY_PATH) -tool analyze_alignment -args '{"action":"todo2"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Alignment analysis completed$(NC)"; \
		$(BINARY_PATH) -tool health -args '{"action":"docs"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Docs health check completed$(NC)"; \
		echo "$(GREEN)‚úÖ Pre-sprint cleanup complete$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		$(BINARY_PATH) -tool task_analysis -args '{"action":"duplicates"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Duplicate detection completed$(NC)"; \
		$(BINARY_PATH) -tool analyze_alignment -args '{"action":"todo2"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Alignment analysis completed$(NC)"; \
		$(BINARY_PATH) -tool health -args '{"action":"docs"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Docs health check completed$(NC)"; \
		echo "$(GREEN)‚úÖ Pre-sprint cleanup complete$(NC)"; \
	fi

task-list: ## List tasks (use TASK_FLAGS="--status Todo" for filtering)
	@if [ -f $(BINARY_PATH) ]; then \
		$(BINARY_PATH) task list $(TASK_FLAGS) 2>&1 | grep -v "INFO\|Warning\|Database" || true; \
	else \
		echo "$(RED)‚ùå exarp-go binary not found - run 'make build' first$(NC)"; \
		exit 1; \
	fi

task-list-todo: ## List all Todo tasks
	@$(MAKE) task-list TASK_FLAGS="--status Todo"

task-list-in-progress: ## List all In Progress tasks
	@$(MAKE) task-list TASK_FLAGS="--status \"In Progress\""

task-list-done: ## List all Done tasks
	@$(MAKE) task-list TASK_FLAGS="--status Done"

task-update: ## Update task status (use TASK_ID=id NEW_STATUS=status)
	@if [ -f $(BINARY_PATH) ]; then \
		if [ -z "$(TASK_ID)" ] || [ -z "$(NEW_STATUS)" ]; then \
			echo "$(RED)‚ùå Usage: make task-update TASK_ID=T-123 NEW_STATUS=Done$(NC)"; \
			exit 1; \
		fi; \
		$(BINARY_PATH) task update $(TASK_ID) --new-status "$(NEW_STATUS)" 2>&1 | grep -v "INFO\|Warning\|Database" || true; \
	else \
		echo "$(RED)‚ùå exarp-go binary not found - run 'make build' first$(NC)"; \
		exit 1; \
	fi

##@ exarp-go tools (CLI)

define exarp_run
@if [ -f $(BINARY_PATH) ]; then \
	$(BINARY_PATH) $(1); \
else \
	echo "$(RED)‚ùå exarp-go binary not found - run 'make build' first$(NC)"; \
	exit 1; \
fi
endef

_exarp_report_scorecard_args := '{"action":"scorecard","include_metrics":true}'
_exarp_report_overview_args   := '{"action":"overview","include_metrics":true}'

exarp-list: ## List exarp-go tools (CLI)
	$(call exarp_run,-list)

exarp-report-scorecard: ## Run report tool (action=scorecard) via exarp-go CLI
	$(call exarp_run,-tool report -args $(_exarp_report_scorecard_args))

exarp-report-overview: ## Run report tool (action=overview) via exarp-go CLI
	$(call exarp_run,-tool report -args $(_exarp_report_overview_args))

exarp-health-server: ## Run health tool (action=server) via exarp-go CLI
	$(call exarp_run,-tool health -args '{"action":"server"}')

exarp-health-docs: ## Run health tool (action=docs) via exarp-go CLI
	$(call exarp_run,-tool health -args '{"action":"docs"}')

exarp-context-budget: ## Run context budget; use CONTEXT_JSON='{"action":"budget","items":["a","b"],"budget_tokens":4000}' or leave default
	@CONTEXT_JSON=$${CONTEXT_JSON:-'{"action":"budget","items":["README","docs"],"budget_tokens":4000}'}; \
	if [ ! -f $(BINARY_PATH) ]; then \
		echo "$(RED)‚ùå exarp-go binary not found - run 'make build' first$(NC)"; exit 1; \
	fi; \
	$(BINARY_PATH) -tool context -args "$$CONTEXT_JSON"

exarp-test: ## Smoke-test a tool via exarp-go -test; use TOOL=name (e.g. make exarp-test TOOL=health)
	@if [ -z "$(TOOL)" ]; then \
		echo "$(RED)‚ùå Usage: make exarp-test TOOL=health$(NC)"; \
		exit 1; \
	fi
	$(call exarp_run,-test $(TOOL))

sprint: ## Run full sprint automation (process all background tasks)
	@echo "$(BLUE)Running sprint automation...$(NC)"
	@if [ -f $(BINARY_PATH) ]; then \
		$(BINARY_PATH) -tool automation -args '{"action":"sprint","max_iterations":10,"auto_approve":true,"extract_subtasks":true,"run_analysis_tools":true,"run_testing_tools":true}' || \
		echo "$(YELLOW)‚ö†Ô∏è  Sprint automation completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Sprint automation complete$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		$(BINARY_PATH) -tool automation -args '{"action":"sprint","max_iterations":10,"auto_approve":true,"extract_subtasks":true,"run_analysis_tools":true,"run_testing_tools":true}' || \
		echo "$(YELLOW)‚ö†Ô∏è  Sprint automation completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Sprint automation complete$(NC)"; \
	fi

# Native Go: infer_task_progress tool (no Python or agentic-tools MCP required).
# use_fm=false keeps runs fast on large backlogs; set use_fm=true for FM-enhanced inference.
check-tasks: build ## Batch check all Todo and In Progress tasks to find completed ones (dry run)
	@echo "$(BLUE)Checking tasks for completion (dry run)...$(NC)"
	@PROJECT_ROOT="$(shell pwd)" $(BINARY_PATH) -tool infer_task_progress -args '{"dry_run": true, "use_fm": false, "output_path": "docs/TASK_COMPLETION_CHECK.md"}' && \
		echo "$(GREEN)‚úÖ Task completion check complete (dry run)$(NC)" || \
		(echo "$(YELLOW)‚ö†Ô∏è  Task check completed (check output above)$(NC)" && exit 1)

# Native Go: same as check-tasks but auto_update_tasks=true (updates task status to Done).
update-completed-tasks: build ## Batch check and auto-update completed tasks (updates task status)
	@echo "$(BLUE)Checking and updating completed tasks...$(NC)"
	@echo "$(YELLOW)‚ö†Ô∏è  This will update task statuses based on codebase analysis$(NC)"
	@PROJECT_ROOT="$(shell pwd)" $(BINARY_PATH) -tool infer_task_progress -args '{"dry_run": false, "auto_update_tasks": true, "use_fm": false, "output_path": "docs/TASK_COMPLETION_UPDATE.md"}' && \
		echo "$(GREEN)‚úÖ Completed tasks updated$(NC)" || \
		(echo "$(YELLOW)‚ö†Ô∏è  Task update completed (check output above)$(NC)" && exit 1)

task-sanity-check: build ## Run generic Todo2 task sanity check (epoch dates, empty content, valid status, duplicate IDs, missing deps)
	@echo "$(BLUE)Running Todo2 task sanity check...$(NC)"
	@PROJECT_ROOT="$(shell pwd)" $(BINARY_PATH) -tool task_workflow -args '{"action":"sanity_check"}' && \
		echo "$(GREEN)‚úÖ Task sanity check passed$(NC)" || \
		(echo "$(RED)‚ùå Task sanity check found issues$(NC)" && exit 1)

##@ Data Migration

migrate: build-migrate ## Run JSON to SQLite migration tool (requires build-migrate first)
	@echo "$(BLUE)Running migration tool...$(NC)"
	@./bin/migrate --backup || (echo "$(RED)‚ùå Migration failed$(NC)" && exit 1)

migrate-dry-run: build-migrate ## Preview migration without actually migrating
	@echo "$(BLUE)Running migration tool (dry run)...$(NC)"
	@./bin/migrate --dry-run

##@ Go Module Management

go-mod-tidy: ## Run go mod tidy to clean up dependencies
	@echo "$(BLUE)Running go mod tidy...$(NC)"
	@$(GO) mod tidy || (echo "$(RED)‚ùå go mod tidy failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Dependencies cleaned$(NC)"

go-mod-verify: ## Verify go.mod and go.sum are in sync
	@echo "$(BLUE)Verifying go.mod and go.sum...$(NC)"
	@$(GO) mod verify || (echo "$(RED)‚ùå Module verification failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Module verification passed$(NC)"

##@ Protocol Buffers

proto: ## Generate Go code from .proto files
	@echo "$(BLUE)Generating Go code from protobuf schemas...$(NC)"
	@if ! command -v protoc >/dev/null 2>&1; then \
		echo "$(RED)‚ùå protoc not found. Install with:$(NC)"; \
		echo "$(YELLOW)   macOS: brew install protobuf$(NC)"; \
		echo "$(YELLOW)   Linux: apt-get install protobuf-compiler$(NC)"; \
		exit 1; \
	fi
	@if ! command -v protoc-gen-go >/dev/null 2>&1 && [ ! -x "$$HOME/go/bin/protoc-gen-go" ]; then \
		echo "$(BLUE)Installing protoc-gen-go...$(NC)"; \
		$(GO) install google.golang.org/protobuf/cmd/protoc-gen-go@latest || \
		(echo "$(RED)‚ùå Failed to install protoc-gen-go$(NC)" && exit 1); \
		echo "$(GREEN)‚úÖ protoc-gen-go installed$(NC)"; \
	fi
	@protoc --go_out=. --go_opt=paths=source_relative \
		proto/todo2.proto \
		proto/bridge.proto \
		proto/config.proto \
		proto/tools.proto || \
		(echo "$(RED)‚ùå Protobuf code generation failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Protobuf code generated$(NC)"

proto-check: ## Validate .proto files (syntax check)
	@echo "$(BLUE)Validating protobuf schemas...$(NC)"
	@if ! command -v protoc >/dev/null 2>&1; then \
		echo "$(RED)‚ùå protoc not found. Install with:$(NC)"; \
		echo "$(YELLOW)   macOS: brew install protobuf$(NC)"; \
		echo "$(YELLOW)   Linux: apt-get install protobuf-compiler$(NC)"; \
		exit 1; \
	fi
	@for proto_file in proto/*.proto; do \
		echo "Checking $$proto_file..."; \
		protoc --proto_path=proto --descriptor_set_out=/dev/null $$proto_file 2>&1 || \
			(echo "$(RED)‚ùå Validation failed for $$proto_file$(NC)" && exit 1); \
	done
	@echo "$(GREEN)‚úÖ All protobuf schemas are valid$(NC)"

proto-clean: ## Clean generated protobuf Go code
	@echo "$(BLUE)Cleaning generated protobuf code...$(NC)"
	@rm -rf proto/todo2 proto/bridge proto/config
	@echo "$(GREEN)‚úÖ Protobuf code cleaned$(NC)"

##@ Tool Installation

install-tools: ## Install Go development tools (golangci-lint, govulncheck, protoc-gen-go)
	@echo "$(BLUE)Installing Go development tools...$(NC)"
	@if ! command -v golangci-lint >/dev/null 2>&1; then \
		echo "$(BLUE)Installing golangci-lint...$(NC)"; \
		$(GO) install github.com/golangci/golangci-lint/cmd/golangci-lint@latest || \
		(echo "$(YELLOW)‚ö†Ô∏è  Failed to install golangci-lint$(NC)" && exit 1); \
		echo "$(GREEN)‚úÖ golangci-lint installed$(NC)"; \
	else \
		echo "$(GREEN)‚úÖ golangci-lint already installed$(NC)"; \
	fi
	@if ! command -v govulncheck >/dev/null 2>&1 && [ ! -x "$$HOME/go/bin/govulncheck" ]; then \
		echo "$(BLUE)Installing govulncheck...$(NC)"; \
		$(GO) install golang.org/x/vuln/cmd/govulncheck@latest || \
		(echo "$(YELLOW)‚ö†Ô∏è  Failed to install govulncheck$(NC)" && exit 1); \
		echo "$(GREEN)‚úÖ govulncheck installed$(NC)"; \
	else \
		echo "$(GREEN)‚úÖ govulncheck already installed$(NC)"; \
	fi
	@if ! command -v protoc-gen-go >/dev/null 2>&1 && [ ! -x "$$HOME/go/bin/protoc-gen-go" ]; then \
		echo "$(BLUE)Installing protoc-gen-go...$(NC)"; \
		$(GO) install google.golang.org/protobuf/cmd/protoc-gen-go@latest || \
		(echo "$(YELLOW)‚ö†Ô∏è  Failed to install protoc-gen-go$(NC)" && exit 1); \
		echo "$(GREEN)‚úÖ protoc-gen-go installed$(NC)"; \
	else \
		echo "$(GREEN)‚úÖ protoc-gen-go already installed$(NC)"; \
	fi
	@echo "$(GREEN)‚úÖ All tools installed$(NC)"

##@ Pre-commit Checks

pre-commit: go-mod-tidy go-fmt go-vet check ## Run pre-commit checks (tidy + fmt + vet + lint)
	@echo "$(GREEN)‚úÖ Pre-commit checks passed$(NC)"

validate: go-mod-verify check test ## Validate code before commit (verify + check + test)
	@echo "$(GREEN)‚úÖ Code validation passed$(NC)"

##@ CI/CD

ci: go-mod-verify check test ## Run CI checks (verify + check + test)
	@echo "$(GREEN)‚úÖ CI checks passed$(NC)"

##@ Dependency Management

check-deps: ## Check for outdated Go dependencies
	@echo "$(BLUE)Checking for outdated dependencies...$(NC)"
	@$(GO) list -u -m all 2>/dev/null | grep -E "\[.*\]" || \
	 (echo "$(GREEN)‚úÖ All dependencies are up to date$(NC)" && exit 0)
	@echo "$(YELLOW)‚ö†Ô∏è  Some dependencies may be outdated (see above)$(NC)"

##@ Version Information

version: ## Show version information
	@echo "$(BLUE)Version Information:$(NC)"
	@echo "  Project:     $(PROJECT_NAME)"
	@echo "  Version:     $(VERSION)"
	@echo "  Build Time:  $(BUILD_TIME)"
	@echo "  Git Commit:  $(GIT_COMMIT)"
	@echo "  Go Version:  $$($(GO) version 2>/dev/null || echo 'unknown')"

##@ Quick Commands

quick-test: test-tools ## Quick test (tools only)
quick-dev: dev ## Quick dev mode (watch only)
quick-build: build ## Quick build (verify imports)

##@ Model-Assisted Testing (Future)

test-models: ## Test model integration (MLX/Ollama)
	@echo "$(BLUE)Testing model integration...$(NC)"
	@echo "$(YELLOW)Model integration testing via Go server$(NC)"

test-breakdown: ## Test task breakdown with models
	@echo "$(BLUE)Testing task breakdown...$(NC)"
	@echo "$(YELLOW)Model-assisted testing not yet implemented$(NC)"

test-auto-exec: ## Test auto-execution with models
	@echo "$(BLUE)Testing auto-execution...$(NC)"
	@echo "$(YELLOW)Model-assisted testing not yet implemented$(NC)"

