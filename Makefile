.PHONY: help build run test test-watch test-coverage test-html clean install fmt lint dev dev-watch dev-test dev-full bench docs sanity-check test-cli test-cli-list test-cli-tool test-cli-test config clean-config

# Project configuration
PROJECT_NAME := mcp-stdio-tools
PYTHON := uv run python
BINARY_NAME := exarp-go
BINARY_PATH := bin/$(BINARY_NAME)

# Load configuration (generated by 'make config')
-include .make.config

# Detect Go binary (check PATH first, then common locations)
GO := $(shell if command -v go >/dev/null 2>&1; then echo go; elif [ -x /usr/local/go/bin/go ]; then echo /usr/local/go/bin/go; elif [ -x $$HOME/.local/go/bin/go ]; then echo $$HOME/.local/go/bin/go; else echo go; fi)

# Colors for output
GREEN := \033[0;32m
YELLOW := \033[1;33m
RED := \033[0;31m
BLUE := \033[0;34m
NC := \033[0m # No Color

# Default target
.DEFAULT_GOAL := help

##@ Configuration

config: ## Configure build system (detect available tools)
	@echo "$(BLUE)Configuring build system...$(NC)"
	@echo "# Auto-generated by 'make config' - DO NOT EDIT MANUALLY" > .make.config
	@echo "# Run 'make config' to regenerate" >> .make.config
	@echo "" >> .make.config
	@# Detect uv
	@if command -v uv >/dev/null 2>&1 || [ -x "$$HOME/.cargo/bin/uv" ] || [ -x "$$HOME/.local/bin/uv" ]; then \
		echo "HAVE_UV = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: uv$(NC)"; \
	else \
		echo "HAVE_UV = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: uv (optional - for Python tests)$(NC)"; \
	fi
	@# Detect pytest
	@if command -v uv >/dev/null 2>&1 && uv run python -m pytest --version >/dev/null 2>&1; then \
		echo "HAVE_PYTEST = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: pytest (via uv)$(NC)"; \
	elif command -v python3 >/dev/null 2>&1 && python3 -m pytest --version >/dev/null 2>&1; then \
		echo "HAVE_PYTEST = 1" >> .make.config; \
		echo "PYTHON_CMD = python3" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: pytest (via python3)$(NC)"; \
	else \
		echo "HAVE_PYTEST = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: pytest (optional - for Python tests)$(NC)"; \
	fi
	@# Detect exarp-go binary
	@if [ -f $(BINARY_PATH) ]; then \
		echo "HAVE_EXARP_GO = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: exarp-go binary$(NC)"; \
	else \
		echo "HAVE_EXARP_GO = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: exarp-go binary (run 'make build' first)$(NC)"; \
	fi
	@# Detect file watchers
	@if command -v fswatch >/dev/null 2>&1 || command -v inotifywait >/dev/null 2>&1; then \
		echo "HAVE_FILE_WATCHER = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: file watcher (fswatch/inotifywait)$(NC)"; \
	else \
		echo "HAVE_FILE_WATCHER = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: file watcher (optional - dev mode will use polling)$(NC)"; \
	fi
	@echo "" >> .make.config
	@echo "$(GREEN)‚úÖ Configuration complete: .make.config$(NC)"

clean-config: ## Remove configuration file
	@rm -f .make.config
	@echo "$(GREEN)‚úÖ Configuration file removed$(NC)"

##@ Development

help: ## Show this help message
	@echo "$(BLUE)Available targets:$(NC)"
	@grep -hE '^[a-zA-Z_-]+:.*?## .*$$' Makefile | awk 'BEGIN {FS = ":.*?## "} {printf "  $(GREEN)%-20s$(NC) %s\n", $$1, $$2}'
	@if [ ! -f .make.config ]; then \
		echo ""; \
		echo "$(YELLOW)üí° Tip: Run 'make config' to detect available tools and optimize targets$(NC)"; \
	fi

build: ## Build the Go server
	@echo "$(BLUE)Building $(PROJECT_NAME)...$(NC)"
	@if ! command -v $(GO) >/dev/null 2>&1 && [ ! -x "$(GO)" ]; then \
		echo "$(RED)‚ùå Go not found. Install Go or set PATH to include Go bin directory$(NC)"; \
		exit 1; \
	fi
	@$(GO) build -o $(BINARY_PATH) ./cmd/server || (echo "$(RED)‚ùå Build failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Server built: $(BINARY_PATH)$(NC)"

run: build ## Run the MCP server
	@echo "$(BLUE)Running $(PROJECT_NAME) server...$(NC)"
	@$(BINARY_PATH)

dev: ## Start development mode (auto-reload on changes)
	@echo "$(BLUE)Starting development mode...$(NC)"
	@./dev.sh --watch

dev-watch: ## Watch files and auto-reload (alias for dev)
	@$(MAKE) dev

dev-test: ## Development mode with auto-test on changes
	@echo "$(BLUE)Starting development mode with auto-test...$(NC)"
	@./dev.sh --watch --test

dev-full: ## Full development mode (watch + test + coverage)
	@echo "$(BLUE)Starting full development mode...$(NC)"
	@./dev.sh --watch --test --coverage

##@ Testing

test: test-go $(if $(filter 1,$(HAVE_PYTEST)),test-python,) ## Run all tests (Go + Python)
	@echo "$(GREEN)‚úÖ All tests passed$(NC)"

test-go: ## Run Go tests
	@echo "$(BLUE)Running Go tests...$(NC)"
	@$(GO) test ./... -v || \
	 echo "$(YELLOW)‚ö†Ô∏è  Go tests failed or not available$(NC)"

test-python: ## Run Python tests (requires pytest)
ifeq ($(HAVE_PYTEST),1)
	@echo "$(BLUE)Running Python tests...$(NC)"
	@if command -v uv >/dev/null 2>&1 || [ -x "$$HOME/.cargo/bin/uv" ] || [ -x "$$HOME/.local/bin/uv" ]; then \
		$(PYTHON) -m pytest tests/unit/python tests/integration -v || \
		echo "$(YELLOW)‚ö†Ô∏è  Python tests failed$(NC)"; \
	elif [ -n "$(PYTHON_CMD)" ]; then \
		$(PYTHON_CMD) -m pytest tests/unit/python tests/integration -v || \
		echo "$(YELLOW)‚ö†Ô∏è  Python tests failed$(NC)"; \
	else \
		python3 -m pytest tests/unit/python tests/integration -v || \
		echo "$(YELLOW)‚ö†Ô∏è  Python tests failed$(NC)"; \
	fi
else
	@echo "$(YELLOW)‚ö†Ô∏è  pytest not available - skipping Python tests$(NC)"
	@echo "$(YELLOW)   Install: 'make config' or 'make install-dev'$(NC)"
endif

test-integration: ## Run integration tests (requires pytest)
ifeq ($(HAVE_PYTEST),1)
	@echo "$(BLUE)Running integration tests...$(NC)"
	@if command -v uv >/dev/null 2>&1 || [ -x "$$HOME/.cargo/bin/uv" ] || [ -x "$$HOME/.local/bin/uv" ]; then \
		$(PYTHON) -m pytest tests/integration -v || \
		echo "$(YELLOW)‚ö†Ô∏è  Integration tests failed$(NC)"; \
	else \
		python3 -m pytest tests/integration -v || \
		echo "$(YELLOW)‚ö†Ô∏è  Integration tests failed$(NC)"; \
	fi
	@echo "$(BLUE)Running Go tests for coverage...$(NC)"
	@$(GO) test ./... -v || echo "$(YELLOW)‚ö†Ô∏è  Go tests failed$(NC)"
else
	@echo "$(YELLOW)‚ö†Ô∏è  pytest not available - skipping integration tests$(NC)"
	@echo "$(BLUE)Running Go tests...$(NC)"
	@$(GO) test ./... -v || echo "$(YELLOW)‚ö†Ô∏è  Go tests failed$(NC)"
endif

test-coverage: test-coverage-go $(if $(filter 1,$(HAVE_PYTEST)),test-coverage-python,) ## Run tests with coverage report

test-coverage-go: ## Generate Go test coverage report
	@echo "$(BLUE)Running Go tests with coverage...$(NC)"
	@$(GO) test ./... -coverprofile=coverage-go.out -covermode=atomic || \
	 echo "$(YELLOW)‚ö†Ô∏è  Go coverage failed$(NC)"
	@$(GO) tool cover -html=coverage-go.out -o coverage-go.html 2>/dev/null || true
	@echo "$(GREEN)‚úÖ Go coverage report: coverage-go.html$(NC)"

test-coverage-python: ## Generate Python test coverage report (requires pytest)
ifeq ($(HAVE_PYTEST),1)
	@echo "$(BLUE)Running Python tests with coverage...$(NC)"
	@if command -v uv >/dev/null 2>&1 || [ -x "$$HOME/.cargo/bin/uv" ] || [ -x "$$HOME/.local/bin/uv" ]; then \
		$(PYTHON) -m pytest tests/unit/python tests/integration \
			--cov=bridge --cov=internal --cov-report=term --cov-report=html || \
		echo "$(YELLOW)‚ö†Ô∏è  Python coverage failed$(NC)"; \
	else \
		python3 -m pytest tests/unit/python tests/integration \
			--cov=bridge --cov=internal --cov-report=term --cov-report=html || \
		echo "$(YELLOW)‚ö†Ô∏è  Python coverage failed$(NC)"; \
	fi
	@echo "$(GREEN)‚úÖ Python coverage report: htmlcov/index.html$(NC)"
else
	@echo "$(YELLOW)‚ö†Ô∏è  pytest not available - skipping Python coverage$(NC)"
endif

test-html: test-coverage ## Generate HTML coverage reports (alias for test-coverage)

test-watch: ## Run tests in watch mode (auto-test on changes)
	@echo "$(BLUE)Starting test watch mode...$(NC)"
	@./dev.sh --test-watch

test-tools: build ## Test Go server tools
	@echo "$(BLUE)Testing Go server...$(NC)"
	@test -f $(BINARY_PATH) && echo "$(GREEN)‚úÖ Go binary exists$(NC)" || (echo "$(RED)‚ùå Go binary not found$(NC)" && exit 1)
	@test -x $(BINARY_PATH) && echo "$(GREEN)‚úÖ Go binary is executable$(NC)" || (echo "$(RED)‚ùå Go binary is not executable$(NC)" && exit 1)

sanity-check: ## Verify tools/resources/prompts counts match expected values
	@echo "$(BLUE)Running sanity check...$(NC)"
	@$(GO) build -o bin/sanity-check cmd/sanity-check/main.go 2>/dev/null || true
	@./bin/sanity-check || (echo "$(RED)‚ùå Sanity check failed$(NC)" && exit 1)

test-all: test-tools sanity-check test-cli ## Run all import tests + sanity check + CLI tests

test-mcp: ## Test MCP server via stdio (requires manual input)
	@echo "$(BLUE)Testing MCP server (stdio mode)...$(NC)"
	@echo "$(YELLOW)Note: This requires manual JSON-RPC input$(NC)"
	@$(BINARY_PATH) < /dev/stdin

##@ CLI Testing

test-cli: build test-cli-list test-cli-tool test-cli-test ## Run all CLI functionality tests
	@echo "$(GREEN)‚úÖ All CLI tests passed$(NC)"

test-cli-list: build ## Test CLI list tools functionality
	@echo "$(BLUE)Testing CLI: list tools...$(NC)"
	@$(BINARY_PATH) -list > /dev/null 2>&1 && \
	 echo "$(GREEN)‚úÖ CLI list command works$(NC)" || \
	 (echo "$(RED)‚ùå CLI list command failed$(NC)" && exit 1)

test-cli-tool: build ## Test CLI tool execution
	@echo "$(BLUE)Testing CLI: tool execution...$(NC)"
	@$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"go-vet","path":"cmd/server"}' > /dev/null 2>&1 && \
	 echo "$(GREEN)‚úÖ CLI tool execution works$(NC)" || \
	 (echo "$(YELLOW)‚ö†Ô∏è  CLI tool execution test skipped (may require valid tool/args)$(NC)")

test-cli-test: build ## Test CLI feature testing mode
	@echo "$(BLUE)Testing CLI: feature testing mode...$(NC)"
	@$(BINARY_PATH) -test lint > /dev/null 2>&1 && \
	 echo "$(GREEN)‚úÖ CLI test mode works$(NC)" || \
	 (echo "$(YELLOW)‚ö†Ô∏è  CLI test mode skipped (may require valid tool)$(NC)")

test-cli-help: build ## Test CLI help/usage display
	@echo "$(BLUE)Testing CLI: help display...$(NC)"
	@$(BINARY_PATH) 2>&1 | grep -qE "(Usage|exarp-go)" && \
	 echo "$(GREEN)‚úÖ CLI help display works$(NC)" || \
	 (echo "$(YELLOW)‚ö†Ô∏è  CLI help display test inconclusive$(NC)")

test-cli-mode: build ## Test CLI mode detection (TTY vs stdio)
	@echo "$(BLUE)Testing CLI: mode detection...$(NC)"
	@echo "$(BLUE)  Testing TTY mode (should show CLI)...$(NC)"
	@$(BINARY_PATH) -list > /dev/null 2>&1 && \
	 echo "$(GREEN)  ‚úÖ TTY mode detected correctly$(NC)" || \
	 echo "$(YELLOW)  ‚ö†Ô∏è  TTY mode test inconclusive$(NC)"
	@echo "$(BLUE)  Testing stdio mode (should run as MCP server)...$(NC)"
	@echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}' | timeout 2 $(BINARY_PATH) 2>&1 | grep -q "jsonrpc" && \
	 echo "$(GREEN)  ‚úÖ Stdio mode detected correctly$(NC)" || \
	 echo "$(YELLOW)  ‚ö†Ô∏è  Stdio mode test inconclusive (may timeout)$(NC)"

##@ Code Quality

fmt: ## Format code with exarp-go (gofmt/goimports) (requires build)
ifeq ($(HAVE_EXARP_GO),1)
	@echo "$(BLUE)Formatting code...$(NC)"
	@$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"gofmt","path":".","fix":true}' 2>/dev/null || \
		echo "$(YELLOW)exarp-go format tool completed (check output above)$(NC)"
	@echo "$(GREEN)‚úÖ Code formatted$(NC)"
else
	@echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"
	@echo "$(YELLOW)   Building binary first...$(NC)"
	@$(MAKE) build
	@$(MAKE) fmt
endif

lint: ## Lint code with exarp-go (requires build)
ifeq ($(HAVE_EXARP_GO),1)
	@echo "$(BLUE)Linting code...$(NC)"
	@$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"auto","path":"."}' 2>/dev/null || \
		echo "$(YELLOW)exarp-go lint tool completed (check output above)$(NC)"
	@echo "$(GREEN)‚úÖ Linting complete$(NC)"
else
	@echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"
	@echo "$(YELLOW)   Building binary first...$(NC)"
	@$(MAKE) build
	@$(MAKE) lint
endif

lint-fix: ## Lint and auto-fix code with exarp-go (requires build)
ifeq ($(HAVE_EXARP_GO),1)
	@echo "$(BLUE)Linting and fixing code...$(NC)"
	@$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"auto","path":".","fix":true}' 2>/dev/null || \
		echo "$(YELLOW)exarp-go lint-fix tool completed (check output above)$(NC)"
	@echo "$(GREEN)‚úÖ Linting and fixes complete$(NC)"
else
	@echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"
	@echo "$(YELLOW)   Building binary first...$(NC)"
	@$(MAKE) build
	@$(MAKE) lint-fix
endif

##@ Benchmarking

bench: ## Run benchmarks (requires pytest)
ifeq ($(HAVE_PYTEST),1)
	@echo "$(BLUE)Running benchmarks...$(NC)"
	@if command -v uv >/dev/null 2>&1 || [ -x "$$HOME/.cargo/bin/uv" ] || [ -x "$$HOME/.local/bin/uv" ]; then \
		$(PYTHON) -m pytest tests/benchmarks/ -v --benchmark-only 2>/dev/null || \
		echo "$(YELLOW)No benchmarks found$(NC)"; \
	else \
		python3 -m pytest tests/benchmarks/ -v --benchmark-only 2>/dev/null || \
		echo "$(YELLOW)No benchmarks found$(NC)"; \
	fi
else
	@echo "$(YELLOW)‚ö†Ô∏è  pytest not available - skipping benchmarks$(NC)"
endif

##@ Documentation

docs: ## Generate documentation
	@echo "$(BLUE)Generating documentation...$(NC)"
	@echo "$(YELLOW)Documentation generation not available for Go server$(NC)"

##@ Cleanup

clean: ## Clean build artifacts and cache
	@echo "$(BLUE)Cleaning...$(NC)"
	@rm -rf __pycache__ .pytest_cache .coverage htmlcov/ .ruff_cache/
	@find . -type d -name __pycache__ -exec rm -r {} + 2>/dev/null || true
	@find . -type f -name "*.pyc" -delete 2>/dev/null || true
	@echo "$(GREEN)‚úÖ Clean complete$(NC)"

clean-all: clean ## Clean everything including virtual environment
	@echo "$(BLUE)Cleaning everything...$(NC)"
	@rm -rf .venv/ uv.lock
	@echo "$(GREEN)‚úÖ Full clean complete$(NC)"

##@ Installation

install: ## Install Python dependencies (optional - no runtime deps needed)
	@echo "$(BLUE)Installing Python dependencies...$(NC)"
	@if command -v uv >/dev/null 2>&1; then \
		uv sync || echo "$(YELLOW)uv sync failed, but no runtime Python deps needed$(NC)"; \
	elif [ -x "$HOME/.cargo/bin/uv" ]; then \
		"$HOME/.cargo/bin/uv" sync || echo "$(YELLOW)uv sync failed, but no runtime Python deps needed$(NC)"; \
	elif [ -x "$HOME/.local/bin/uv" ]; then \
		"$HOME/.local/bin/uv" sync || echo "$(YELLOW)uv sync failed, but no runtime Python deps needed$(NC)"; \
	else \
		echo "$(YELLOW)uv not found - skipping Python dependencies$(NC)"; \
		echo "$(YELLOW)Note: No runtime Python dependencies needed (bridge scripts use stdlib only)$(NC)"; \
		echo "$(YELLOW)Install uv: curl -LsSf https://astral.sh/uv/install.sh | sh$(NC)"; \
	fi
	@echo "$(GREEN)‚úÖ Dependencies check complete$(NC)"

install-dev: install ## Install Python development dependencies (optional)
	@echo "$(BLUE)Installing Python development dependencies...$(NC)"
	@if command -v uv >/dev/null 2>&1; then \
		uv sync --dev || echo "$(YELLOW)uv sync --dev failed$(NC)"; \
	elif [ -x "$HOME/.cargo/bin/uv" ]; then \
		"$HOME/.cargo/bin/uv" sync --dev || echo "$(YELLOW)uv sync --dev failed$(NC)"; \
	elif [ -x "$HOME/.local/bin/uv" ]; then \
		"$HOME/.local/bin/uv" sync --dev || echo "$(YELLOW)uv sync --dev failed$(NC)"; \
	else \
		echo "$(YELLOW)uv not found - skipping Python dev dependencies$(NC)"; \
		echo "$(YELLOW)Dev deps are optional (pytest, black, ruff) - only needed for Python testing$(NC)"; \
		echo "$(YELLOW)Install uv: curl -LsSf https://astral.sh/uv/install.sh | sh$(NC)"; \
	fi
	@echo "$(GREEN)‚úÖ Development dependencies check complete$(NC)"

##@ Go Development

go-build: ## Build Go binary
	@echo "$(BLUE)Building Go binary...$(NC)"
	@if ! command -v $(GO) >/dev/null 2>&1 && [ ! -x "$(GO)" ]; then \
		echo "$(RED)‚ùå Go not found. Install Go or set PATH to include Go bin directory$(NC)"; \
		exit 1; \
	fi
	@$(GO) build -o $(BINARY_PATH) ./cmd/server || \
	 (echo "$(RED)‚ùå Build failed$(NC)" && exit 1)
	@chmod +x $(BINARY_PATH)
	@echo "$(GREEN)‚úÖ Build complete: $(BINARY_PATH)$(NC)"

go-run: go-build ## Run Go binary
	@echo "$(BLUE)Running $(BINARY_NAME)...$(NC)"
	@$(BINARY_PATH)

go-dev: ## Start Go development mode (hot reload)
	@echo "$(BLUE)Starting Go development mode...$(NC)"
	@./dev-go.sh --watch

go-dev-test: ## Go dev mode with auto-test
	@echo "$(BLUE)Starting Go development mode with auto-test...$(NC)"
	@./dev-go.sh --watch --test

go-test: ## Run Go tests
	@echo "$(BLUE)Running Go tests...$(NC)"
	@$(GO) test ./... -v || \
	 (echo "$(RED)‚ùå Tests failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ All tests passed$(NC)"

go-bench: ## Run Go benchmarks
	@echo "$(BLUE)Running Go benchmarks...$(NC)"
	@$(GO) test -bench=. -benchmem ./... || \
	 echo "$(YELLOW)‚ö†Ô∏è  Benchmarks failed$(NC)"

##@ Quick Commands

quick-test: test-tools ## Quick test (tools only)
quick-dev: dev ## Quick dev mode (watch only)
quick-build: build ## Quick build (verify imports)

##@ Model-Assisted Testing (Future)

test-models: ## Test model integration (MLX/Ollama)
	@echo "$(BLUE)Testing model integration...$(NC)"
	@echo "$(YELLOW)Model integration testing via Go server$(NC)"

test-breakdown: ## Test task breakdown with models
	@echo "$(BLUE)Testing task breakdown...$(NC)"
	@echo "$(YELLOW)Model-assisted testing not yet implemented$(NC)"

test-auto-exec: ## Test auto-execution with models
	@echo "$(BLUE)Testing auto-execution...$(NC)"
	@echo "$(YELLOW)Model-assisted testing not yet implemented$(NC)"

