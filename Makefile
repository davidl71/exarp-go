.PHONY: help build run test test-watch test-coverage test-html clean install fmt lint dev dev-watch dev-test dev-full bench docs sanity-check test-cli test-cli-list test-cli-tool test-cli-test config clean-config sprint-start sprint-end pre-sprint sprint check-tasks update-completed-tasks go-fmt go-vet golangci-lint-check golangci-lint-fix govulncheck check check-fix check-all build-migrate migrate migrate-dry-run build-migrate migrate migrate-dry-run

# Project configuration
PROJECT_NAME := exarp-go
PYTHON := uv run python
BINARY_NAME := exarp-go
BINARY_PATH := bin/$(BINARY_NAME)

# Load configuration (generated by 'make config')
-include .make.config

# Detect Go binary (check PATH first, then common locations)
GO := $(shell if command -v go >/dev/null 2>&1; then echo go; elif [ -x /usr/local/go/bin/go ]; then echo /usr/local/go/bin/go; elif [ -x $$HOME/.local/go/bin/go ]; then echo $$HOME/.local/go/bin/go; else echo go; fi)

# Colors for output
GREEN := \033[0;32m
YELLOW := \033[1;33m
RED := \033[0;31m
BLUE := \033[0;34m
NC := \033[0m # No Color

# Default target
.DEFAULT_GOAL := all

##@ Main Targets

all: build sanity-check test-tools ## Build essential components and run sanity tests
	@echo "$(GREEN)‚úÖ All essential builds and sanity checks completed successfully$(NC)"

##@ Configuration

config: ## Configure build system (detect available tools)
	@echo "$(BLUE)Configuring build system...$(NC)"
	@echo "# Auto-generated by 'make config' - DO NOT EDIT MANUALLY" > .make.config
	@echo "# Run 'make config' to regenerate" >> .make.config
	@echo "" >> .make.config
	@# Detect uv
	@if command -v uv >/dev/null 2>&1 || [ -x "$$HOME/.cargo/bin/uv" ] || [ -x "$$HOME/.local/bin/uv" ]; then \
		echo "HAVE_UV = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: uv$(NC)"; \
	else \
		echo "HAVE_UV = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: uv (optional - for Python tests)$(NC)"; \
	fi
	@# Detect pytest
	@if command -v uv >/dev/null 2>&1 && uv run python -m pytest --version >/dev/null 2>&1; then \
		echo "HAVE_PYTEST = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: pytest (via uv)$(NC)"; \
	elif command -v python3 >/dev/null 2>&1 && python3 -m pytest --version >/dev/null 2>&1; then \
		echo "HAVE_PYTEST = 1" >> .make.config; \
		echo "PYTHON_CMD = python3" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: pytest (via python3)$(NC)"; \
	else \
		echo "HAVE_PYTEST = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: pytest (optional - for Python tests)$(NC)"; \
	fi
	@# Detect exarp-go binary
	@if [ -f $(BINARY_PATH) ]; then \
		echo "HAVE_EXARP_GO = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: exarp-go binary$(NC)"; \
	else \
		echo "HAVE_EXARP_GO = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: exarp-go binary (run 'make build' first)$(NC)"; \
	fi
	@# Detect file watchers
	@if command -v fswatch >/dev/null 2>&1 || command -v inotifywait >/dev/null 2>&1; then \
		echo "HAVE_FILE_WATCHER = 1" >> .make.config; \
		echo "$(GREEN)‚úÖ Found: file watcher (fswatch/inotifywait)$(NC)"; \
	else \
		echo "HAVE_FILE_WATCHER = 0" >> .make.config; \
		echo "$(YELLOW)‚ö†Ô∏è  Not found: file watcher (optional - dev mode will use polling)$(NC)"; \
	fi
	@echo "" >> .make.config
	@echo "$(GREEN)‚úÖ Configuration complete: .make.config$(NC)"

clean-config: ## Remove configuration file
	@rm -f .make.config
	@echo "$(GREEN)‚úÖ Configuration file removed$(NC)"

##@ Development

help: ## Show this help message
	@echo "$(BLUE)Available targets:$(NC)"
	@grep -hE '^[a-zA-Z_-]+:.*?## .*$$' Makefile | awk 'BEGIN {FS = ":.*?## "} {printf "  $(GREEN)%-20s$(NC) %s\n", $$1, $$2}'
	@if [ ! -f .make.config ]; then \
		echo ""; \
		echo "$(YELLOW)üí° Tip: Run 'make config' to detect available tools and optimize targets$(NC)"; \
	fi
	@echo ""
	@echo "$(BLUE)Quick start:$(NC)"
	@echo "  $(GREEN)make all$(NC)        - Build and run sanity checks (default)"
	@echo "  $(GREEN)make build$(NC)      - Build the binary"
	@echo "  $(GREEN)make test$(NC)       - Run all tests"

build: ## Build the Go server (without CGO by default)
	@echo "$(BLUE)Building $(PROJECT_NAME)...$(NC)"
	@if ! command -v $(GO) >/dev/null 2>&1 && [ ! -x "$(GO)" ]; then \
		echo "$(RED)‚ùå Go not found. Install Go or set PATH to include Go bin directory$(NC)"; \
		exit 1; \
	fi
	@echo "$(YELLOW)Note: Building without CGO (use 'make build-apple-fm' for Apple Foundation Models support)$(NC)"
	@CGO_ENABLED=0 $(GO) build -o $(BINARY_PATH) ./cmd/server || (echo "$(RED)‚ùå Build failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Server built: $(BINARY_PATH)$(NC)"

build-migrate: ## Build JSON to SQLite migration tool
	@echo "$(BLUE)Building migration tool...$(NC)"
	@if ! command -v $(GO) >/dev/null 2>&1 && [ ! -x "$(GO)" ]; then \
		echo "$(RED)‚ùå Go not found. Install Go or set PATH to include Go bin directory$(NC)"; \
		exit 1; \
	fi
	@CGO_ENABLED=1 $(GO) build -o bin/migrate ./cmd/migrate || (echo "$(RED)‚ùå Migration tool build failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Migration tool built: bin/migrate$(NC)"

run: build ## Run the MCP server
	@echo "$(BLUE)Running $(PROJECT_NAME) server...$(NC)"
	@$(BINARY_PATH)

dev: ## Start development mode (auto-reload on changes)
	@echo "$(BLUE)Starting development mode...$(NC)"
	@./dev.sh --watch

dev-watch: ## Watch files and auto-reload (alias for dev)
	@$(MAKE) dev

dev-test: ## Development mode with auto-test on changes
	@echo "$(BLUE)Starting development mode with auto-test...$(NC)"
	@./dev.sh --watch --test

dev-full: ## Full development mode (watch + test + coverage)
	@echo "$(BLUE)Starting full development mode...$(NC)"
	@./dev.sh --watch --test --coverage

##@ Testing

test: test-go $(if $(filter 1,$(HAVE_PYTEST)),test-python,) ## Run all tests (Go + Python)
	@echo "$(GREEN)‚úÖ All tests passed$(NC)"

test-go: ## Run Go tests
	@echo "$(BLUE)Running Go tests...$(NC)"
	@$(GO) test ./... -v || \
	 echo "$(YELLOW)‚ö†Ô∏è  Go tests failed or not available$(NC)"

test-python: ## Run Python tests (requires pytest)
ifeq ($(HAVE_PYTEST),1)
	@echo "$(BLUE)Running Python tests...$(NC)"
	@if command -v uv >/dev/null 2>&1 || [ -x "$$HOME/.cargo/bin/uv" ] || [ -x "$$HOME/.local/bin/uv" ]; then \
		$(PYTHON) -m pytest tests/unit/python tests/integration -v || \
		echo "$(YELLOW)‚ö†Ô∏è  Python tests failed$(NC)"; \
	elif [ -n "$(PYTHON_CMD)" ]; then \
		$(PYTHON_CMD) -m pytest tests/unit/python tests/integration -v || \
		echo "$(YELLOW)‚ö†Ô∏è  Python tests failed$(NC)"; \
	else \
		python3 -m pytest tests/unit/python tests/integration -v || \
		echo "$(YELLOW)‚ö†Ô∏è  Python tests failed$(NC)"; \
	fi
else
	@echo "$(YELLOW)‚ö†Ô∏è  pytest not available - skipping Python tests$(NC)"
	@echo "$(YELLOW)   Install: 'make config' or 'make install-dev'$(NC)"
endif

test-integration: ## Run integration tests (requires pytest)
ifeq ($(HAVE_PYTEST),1)
	@echo "$(BLUE)Running integration tests...$(NC)"
	@if command -v uv >/dev/null 2>&1 || [ -x "$$HOME/.cargo/bin/uv" ] || [ -x "$$HOME/.local/bin/uv" ]; then \
		$(PYTHON) -m pytest tests/integration -v || \
		echo "$(YELLOW)‚ö†Ô∏è  Integration tests failed$(NC)"; \
	else \
		python3 -m pytest tests/integration -v || \
		echo "$(YELLOW)‚ö†Ô∏è  Integration tests failed$(NC)"; \
	fi
	@echo "$(BLUE)Running Go tests for coverage...$(NC)"
	@$(GO) test ./... -v || echo "$(YELLOW)‚ö†Ô∏è  Go tests failed$(NC)"
else
	@echo "$(YELLOW)‚ö†Ô∏è  pytest not available - skipping integration tests$(NC)"
	@echo "$(BLUE)Running Go tests...$(NC)"
	@$(GO) test ./... -v || echo "$(YELLOW)‚ö†Ô∏è  Go tests failed$(NC)"
endif

test-coverage: test-coverage-go $(if $(filter 1,$(HAVE_PYTEST)),test-coverage-python,) ## Run tests with coverage report

test-coverage-go: ## Generate Go test coverage report
	@echo "$(BLUE)Running Go tests with coverage...$(NC)"
	@$(GO) test ./... -coverprofile=coverage-go.out -covermode=atomic || \
	 echo "$(YELLOW)‚ö†Ô∏è  Go coverage failed$(NC)"
	@$(GO) tool cover -html=coverage-go.out -o coverage-go.html 2>/dev/null || true
	@echo "$(GREEN)‚úÖ Go coverage report: coverage-go.html$(NC)"

test-coverage-python: ## Generate Python test coverage report (requires pytest)
ifeq ($(HAVE_PYTEST),1)
	@echo "$(BLUE)Running Python tests with coverage...$(NC)"
	@if command -v uv >/dev/null 2>&1 || [ -x "$$HOME/.cargo/bin/uv" ] || [ -x "$$HOME/.local/bin/uv" ]; then \
		$(PYTHON) -m pytest tests/unit/python tests/integration \
			--cov=bridge --cov=internal --cov-report=term --cov-report=html || \
		echo "$(YELLOW)‚ö†Ô∏è  Python coverage failed$(NC)"; \
	else \
		python3 -m pytest tests/unit/python tests/integration \
			--cov=bridge --cov=internal --cov-report=term --cov-report=html || \
		echo "$(YELLOW)‚ö†Ô∏è  Python coverage failed$(NC)"; \
	fi
	@echo "$(GREEN)‚úÖ Python coverage report: htmlcov/index.html$(NC)"
else
	@echo "$(YELLOW)‚ö†Ô∏è  pytest not available - skipping Python coverage$(NC)"
endif

test-html: test-coverage ## Generate HTML coverage reports (alias for test-coverage)

test-watch: ## Run tests in watch mode (auto-test on changes)
	@echo "$(BLUE)Starting test watch mode...$(NC)"
	@./dev.sh --test-watch

test-tools: build ## Test Go server tools
	@echo "$(BLUE)Testing Go server...$(NC)"
	@test -f $(BINARY_PATH) && echo "$(GREEN)‚úÖ Go binary exists$(NC)" || (echo "$(RED)‚ùå Go binary not found$(NC)" && exit 1)
	@test -x $(BINARY_PATH) && echo "$(GREEN)‚úÖ Go binary is executable$(NC)" || (echo "$(RED)‚ùå Go binary is not executable$(NC)" && exit 1)

sanity-check: ## Verify tools/resources/prompts counts match expected values
	@echo "$(BLUE)Running sanity check...$(NC)"
	@$(GO) build -o bin/sanity-check cmd/sanity-check/main.go 2>/dev/null || true
	@./bin/sanity-check || (echo "$(RED)‚ùå Sanity check failed$(NC)" && exit 1)

test-all: test-tools sanity-check test-cli ## Run all import tests + sanity check + CLI tests

test-mcp: ## Test MCP server via stdio (requires manual input)
	@echo "$(BLUE)Testing MCP server (stdio mode)...$(NC)"
	@echo "$(YELLOW)Note: This requires manual JSON-RPC input$(NC)"
	@$(BINARY_PATH) < /dev/stdin

##@ CLI Testing

test-cli: build test-cli-list test-cli-tool test-cli-test ## Run all CLI functionality tests
	@echo "$(GREEN)‚úÖ All CLI tests passed$(NC)"

test-cli-list: build ## Test CLI list tools functionality
	@echo "$(BLUE)Testing CLI: list tools...$(NC)"
	@$(BINARY_PATH) -list > /dev/null 2>&1 && \
	 echo "$(GREEN)‚úÖ CLI list command works$(NC)" || \
	 (echo "$(RED)‚ùå CLI list command failed$(NC)" && exit 1)

test-cli-tool: build ## Test CLI tool execution
	@echo "$(BLUE)Testing CLI: tool execution...$(NC)"
	@$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"go-vet","path":"cmd/server"}' > /dev/null 2>&1 && \
	 echo "$(GREEN)‚úÖ CLI tool execution works$(NC)" || \
	 (echo "$(YELLOW)‚ö†Ô∏è  CLI tool execution test skipped (may require valid tool/args)$(NC)")

test-cli-test: build ## Test CLI feature testing mode
	@echo "$(BLUE)Testing CLI: feature testing mode...$(NC)"
	@$(BINARY_PATH) -test lint > /dev/null 2>&1 && \
	 echo "$(GREEN)‚úÖ CLI test mode works$(NC)" || \
	 (echo "$(YELLOW)‚ö†Ô∏è  CLI test mode skipped (may require valid tool)$(NC)")

test-cli-help: build ## Test CLI help/usage display
	@echo "$(BLUE)Testing CLI: help display...$(NC)"
	@$(BINARY_PATH) 2>&1 | grep -qE "(Usage|exarp-go)" && \
	 echo "$(GREEN)‚úÖ CLI help display works$(NC)" || \
	 (echo "$(YELLOW)‚ö†Ô∏è  CLI help display test inconclusive$(NC)")

test-cli-mode: build ## Test CLI mode detection (TTY vs stdio)
	@echo "$(BLUE)Testing CLI: mode detection...$(NC)"
	@echo "$(BLUE)  Testing TTY mode (should show CLI)...$(NC)"
	@$(BINARY_PATH) -list > /dev/null 2>&1 && \
	 echo "$(GREEN)  ‚úÖ TTY mode detected correctly$(NC)" || \
	 echo "$(YELLOW)  ‚ö†Ô∏è  TTY mode test inconclusive$(NC)"
	@echo "$(BLUE)  Testing stdio mode (should run as MCP server)...$(NC)"
	@echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}' | timeout 2 $(BINARY_PATH) 2>&1 | grep -q "jsonrpc" && \
	 echo "$(GREEN)  ‚úÖ Stdio mode detected correctly$(NC)" || \
	 echo "$(YELLOW)  ‚ö†Ô∏è  Stdio mode test inconclusive (may timeout)$(NC)"

##@ Code Quality

# Direct Go tool targets (faster, no binary required)
go-fmt: ## Format Go code with gofmt
	@echo "$(BLUE)Formatting Go code with gofmt...$(NC)"
	@$(GO) fmt ./... || (echo "$(RED)‚ùå go fmt failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ Go code formatted$(NC)"

go-vet: ## Check Go code with go vet
	@echo "$(BLUE)Checking Go code with go vet...$(NC)"
	@$(GO) vet ./... || (echo "$(RED)‚ùå go vet found issues$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ go vet passed$(NC)"

golangci-lint-check: ## Check code with golangci-lint
	@echo "$(BLUE)Checking code with golangci-lint...$(NC)"
	@if command -v golangci-lint >/dev/null 2>&1; then \
		golangci-lint run --timeout 5m ./... || (echo "$(RED)‚ùå golangci-lint found issues$(NC)" && exit 1); \
		echo "$(GREEN)‚úÖ golangci-lint passed$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  golangci-lint not found$(NC)"; \
		echo "$(YELLOW)   Install: go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest$(NC)"; \
		exit 1; \
	fi

golangci-lint-fix: ## Fix code with golangci-lint (auto-fix)
	@echo "$(BLUE)Fixing code with golangci-lint...$(NC)"
	@if command -v golangci-lint >/dev/null 2>&1; then \
		golangci-lint run --timeout 5m --fix ./... || (echo "$(YELLOW)‚ö†Ô∏è  Some issues could not be auto-fixed$(NC)"); \
		echo "$(GREEN)‚úÖ golangci-lint fixes applied$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  golangci-lint not found$(NC)"; \
		echo "$(YELLOW)   Install: go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest$(NC)"; \
		exit 1; \
	fi

govulncheck: ## Check for vulnerabilities with govulncheck
	@echo "$(BLUE)Checking for vulnerabilities with govulncheck...$(NC)"
	@if command -v govulncheck >/dev/null 2>&1 || [ -x "$$HOME/go/bin/govulncheck" ]; then \
		if command -v govulncheck >/dev/null 2>&1; then \
			govulncheck ./... || (echo "$(RED)‚ùå Vulnerabilities found$(NC)" && exit 1); \
		else \
			$$HOME/go/bin/govulncheck ./... || (echo "$(RED)‚ùå Vulnerabilities found$(NC)" && exit 1); \
		fi; \
		echo "$(GREEN)‚úÖ No vulnerabilities found$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  govulncheck not found$(NC)"; \
		echo "$(YELLOW)   Install: go install golang.org/x/vuln/cmd/govulncheck@latest$(NC)"; \
		exit 1; \
	fi

check: go-fmt go-vet golangci-lint-check ## Check code quality (fmt + vet + lint)
	@echo "$(GREEN)‚úÖ All code quality checks passed$(NC)"

check-fix: go-fmt golangci-lint-fix ## Check and auto-fix code (fmt + lint-fix)
	@echo "$(GREEN)‚úÖ Code checked and fixed$(NC)"

check-all: check govulncheck ## Run all checks including security (fmt + vet + lint + vulncheck)
	@echo "$(GREEN)‚úÖ All checks passed (including security)$(NC)"

# Legacy targets (using exarp-go binary)
fmt: ## Format code with exarp-go (gofmt/goimports) (requires build)
	@if [ -f $(BINARY_PATH) ]; then \
		echo "$(BLUE)Formatting code...$(NC)"; \
		$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"gofmt","path":".","fix":true}' 2>/dev/null || \
			echo "$(YELLOW)exarp-go format tool completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Code formatted$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		echo "$(BLUE)Formatting code...$(NC)"; \
		$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"gofmt","path":".","fix":true}' 2>/dev/null || \
			echo "$(YELLOW)exarp-go format tool completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Code formatted$(NC)"; \
	fi

lint: ## Lint code with exarp-go (requires build)
	@if [ -f $(BINARY_PATH) ]; then \
		echo "$(BLUE)Linting code...$(NC)"; \
		$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"auto","path":"."}' 2>/dev/null || \
			echo "$(YELLOW)exarp-go lint tool completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Linting complete$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		echo "$(BLUE)Linting code...$(NC)"; \
		$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"auto","path":"."}' 2>/dev/null || \
			echo "$(YELLOW)exarp-go lint tool completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Linting complete$(NC)"; \
	fi

lint-fix: ## Lint and auto-fix code with exarp-go (requires build)
	@if [ -f $(BINARY_PATH) ]; then \
		echo "$(BLUE)Linting and fixing code...$(NC)"; \
		$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"auto","path":".","fix":true}' 2>/dev/null || \
			echo "$(YELLOW)exarp-go lint-fix tool completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Linting and fixes complete$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		echo "$(BLUE)Linting and fixing code...$(NC)"; \
		$(BINARY_PATH) -tool lint -args '{"action":"run","linter":"auto","path":".","fix":true}' 2>/dev/null || \
			echo "$(YELLOW)exarp-go lint-fix tool completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Linting and fixes complete$(NC)"; \
	fi

##@ Benchmarking

bench: ## Run benchmarks (requires pytest)
ifeq ($(HAVE_PYTEST),1)
	@echo "$(BLUE)Running benchmarks...$(NC)"
	@if command -v uv >/dev/null 2>&1 || [ -x "$$HOME/.cargo/bin/uv" ] || [ -x "$$HOME/.local/bin/uv" ]; then \
		$(PYTHON) -m pytest tests/benchmarks/ -v --benchmark-only 2>/dev/null || \
		echo "$(YELLOW)No benchmarks found$(NC)"; \
	else \
		python3 -m pytest tests/benchmarks/ -v --benchmark-only 2>/dev/null || \
		echo "$(YELLOW)No benchmarks found$(NC)"; \
	fi
else
	@echo "$(YELLOW)‚ö†Ô∏è  pytest not available - skipping benchmarks$(NC)"
endif

##@ Documentation

docs: ## Generate documentation
	@echo "$(BLUE)Generating documentation...$(NC)"
	@echo "$(YELLOW)Documentation generation not available for Go server$(NC)"

##@ Cleanup

clean: ## Clean build artifacts and cache
	@echo "$(BLUE)Cleaning...$(NC)"
	@rm -rf __pycache__ .pytest_cache .coverage htmlcov/ .ruff_cache/
	@find . -type d -name __pycache__ -exec rm -r {} + 2>/dev/null || true
	@find . -type f -name "*.pyc" -delete 2>/dev/null || true
	@echo "$(GREEN)‚úÖ Clean complete$(NC)"

clean-all: clean ## Clean everything including virtual environment
	@echo "$(BLUE)Cleaning everything...$(NC)"
	@rm -rf .venv/ uv.lock
	@echo "$(GREEN)‚úÖ Full clean complete$(NC)"

##@ Installation

install: ## Install Python dependencies (optional - no runtime deps needed)
	@echo "$(BLUE)Installing Python dependencies...$(NC)"
	@if command -v uv >/dev/null 2>&1; then \
		uv sync || echo "$(YELLOW)uv sync failed, but no runtime Python deps needed$(NC)"; \
	elif [ -x "$HOME/.cargo/bin/uv" ]; then \
		"$HOME/.cargo/bin/uv" sync || echo "$(YELLOW)uv sync failed, but no runtime Python deps needed$(NC)"; \
	elif [ -x "$HOME/.local/bin/uv" ]; then \
		"$HOME/.local/bin/uv" sync || echo "$(YELLOW)uv sync failed, but no runtime Python deps needed$(NC)"; \
	else \
		echo "$(YELLOW)uv not found - skipping Python dependencies$(NC)"; \
		echo "$(YELLOW)Note: No runtime Python dependencies needed (bridge scripts use stdlib only)$(NC)"; \
		echo "$(YELLOW)Install uv: curl -LsSf https://astral.sh/uv/install.sh | sh$(NC)"; \
	fi
	@echo "$(GREEN)‚úÖ Dependencies check complete$(NC)"

install-dev: install ## Install Python development dependencies (optional)
	@echo "$(BLUE)Installing Python development dependencies...$(NC)"
	@if command -v uv >/dev/null 2>&1; then \
		uv sync --dev || echo "$(YELLOW)uv sync --dev failed$(NC)"; \
	elif [ -x "$HOME/.cargo/bin/uv" ]; then \
		"$HOME/.cargo/bin/uv" sync --dev || echo "$(YELLOW)uv sync --dev failed$(NC)"; \
	elif [ -x "$HOME/.local/bin/uv" ]; then \
		"$HOME/.local/bin/uv" sync --dev || echo "$(YELLOW)uv sync --dev failed$(NC)"; \
	else \
		echo "$(YELLOW)uv not found - skipping Python dev dependencies$(NC)"; \
		echo "$(YELLOW)Dev deps are optional (pytest, black, ruff) - only needed for Python testing$(NC)"; \
		echo "$(YELLOW)Install uv: curl -LsSf https://astral.sh/uv/install.sh | sh$(NC)"; \
	fi
	@echo "$(GREEN)‚úÖ Development dependencies check complete$(NC)"

##@ Go Development

go-build: ## Build Go binary
	@echo "$(BLUE)Building Go binary...$(NC)"
	@if ! command -v $(GO) >/dev/null 2>&1 && [ ! -x "$(GO)" ]; then \
		echo "$(RED)‚ùå Go not found. Install Go or set PATH to include Go bin directory$(NC)"; \
		exit 1; \
	fi
	@$(GO) build -o $(BINARY_PATH) ./cmd/server || \
	 (echo "$(RED)‚ùå Build failed$(NC)" && exit 1)
	@chmod +x $(BINARY_PATH)
	@echo "$(GREEN)‚úÖ Build complete: $(BINARY_PATH)$(NC)"

go-run: go-build ## Run Go binary
	@echo "$(BLUE)Running $(BINARY_NAME)...$(NC)"
	@$(BINARY_PATH)

go-dev: ## Start Go development mode (hot reload)
	@echo "$(BLUE)Starting Go development mode...$(NC)"
	@./dev-go.sh --watch

go-dev-test: ## Go dev mode with auto-test
	@echo "$(BLUE)Starting Go development mode with auto-test...$(NC)"
	@./dev-go.sh --watch --test

go-test: ## Run Go tests
	@echo "$(BLUE)Running Go tests...$(NC)"
	@$(GO) test ./... -v || \
	 (echo "$(RED)‚ùå Tests failed$(NC)" && exit 1)
	@echo "$(GREEN)‚úÖ All tests passed$(NC)"

go-bench: ## Run Go benchmarks (without CGO to avoid Apple FM dependencies)
	@echo "$(BLUE)Running Go benchmarks (CGO_ENABLED=0)...$(NC)"
	@CGO_ENABLED=0 $(GO) test -bench=. -benchmem -benchtime=3s ./internal/tools/... || \
	 echo "$(YELLOW)‚ö†Ô∏è  Go benchmarks failed$(NC)"
	@echo "$(BLUE)Running Go benchmarks...$(NC)"
	@$(GO) test -bench=. -benchmem ./... || \
	 echo "$(YELLOW)‚ö†Ô∏è  Benchmarks failed$(NC)"

##@ Apple Foundation Models

build-apple-fm: build-swift-bridge ## Build with Apple Foundation Models support (CGO_ENABLED=1)
	@echo "$(BLUE)Building with Apple Foundation Models support...$(NC)"
	@if [ -d "vendor" ]; then \
		echo "$(BLUE)Using vendor directory for build...$(NC)"; \
		CGO_ENABLED=1 go build -mod=vendor -o $(BINARY_PATH) ./cmd/server || \
		 (echo "$(RED)‚ùå Build failed - may need Swift bridge$(NC)" && exit 1); \
	else \
		CGO_ENABLED=1 go build -o $(BINARY_PATH) ./cmd/server || \
		 (echo "$(RED)‚ùå Build failed - may need Swift bridge$(NC)" && exit 1); \
	fi
	@echo "$(GREEN)‚úÖ Server built with Apple FM support: $(BINARY_PATH)$(NC)"

build-swift-bridge: ## Build Swift bridge in go-foundationmodels package
	@echo "$(BLUE)Building Swift bridge for go-foundationmodels...$(NC)"
	@echo "$(YELLOW)Note: Module cache is read-only, using vendor directory...$(NC)"
	@if [ ! -d "vendor" ]; then \
		echo "$(BLUE)Creating vendor directory...$(NC)"; \
		go mod vendor; \
	fi
	@if [ -d "vendor/github.com/blacktop/go-foundationmodels" ]; then \
		cd vendor/github.com/blacktop/go-foundationmodels && \
		if [ -f "libFMShim.a" ]; then \
			echo "$(GREEN)‚úÖ Swift bridge already built$(NC)"; \
		else \
			echo "$(BLUE)Compiling Swift bridge...$(NC)"; \
			swiftc -sdk $$(xcrun --show-sdk-path) -target arm64-apple-macos26 -emit-object -parse-as-library -whole-module-optimization -O -o libFMShim.o FoundationModelsShim.swift && \
			ar rcs libFMShim.a libFMShim.o && \
			rm -f libFMShim.o && \
			echo "$(GREEN)‚úÖ Swift bridge built in vendor directory$(NC)"; \
		fi; \
	elif [ -d "$$(go list -m -f '{{.Dir}}' github.com/blacktop/go-foundationmodels@v0.1.8)" ]; then \
		echo "$(YELLOW)‚ö†Ô∏è  Vendor directory not found, trying module cache (may fail)...$(NC)"; \
		cd $$(go list -m -f '{{.Dir}}' github.com/blacktop/go-foundationmodels@v0.1.8) && \
		swiftc -sdk $$(xcrun --show-sdk-path) -target arm64-apple-macos26 -emit-object -parse-as-library -whole-module-optimization -O -o libFMShim.o FoundationModelsShim.swift && \
		ar rcs libFMShim.a libFMShim.o && \
		rm -f libFMShim.o && \
		echo "$(GREEN)‚úÖ Swift bridge built$(NC)"; \
	else \
		echo "$(RED)‚ùå go-foundationmodels package not found$(NC)"; \
		echo "$(YELLOW)   Try running: go mod vendor$(NC)"; \
		exit 1; \
	fi

test-apple-fm: test-apple-fm-unit test-apple-fm-integration ## Run all Apple Foundation Models tests

test-apple-fm-unit: ## Run Apple Foundation Models unit tests (no Swift bridge required)
	@echo "$(BLUE)Running Apple FM unit tests...$(NC)"
	@go test ./internal/tools/apple_foundation_helpers_test.go ./internal/tools/apple_foundation_helpers.go -v || \
	 echo "$(YELLOW)‚ö†Ô∏è  Unit tests failed or skipped$(NC)"

test-apple-fm-integration: build-apple-fm ## Run Apple Foundation Models integration tests (requires Swift bridge)
	@echo "$(BLUE)Running Apple FM integration tests...$(NC)"
	@echo "$(YELLOW)Note: Requires Swift bridge to be built$(NC)"
	@CGO_ENABLED=1 go test ./internal/tools -run TestHandleAppleFoundationModels -v || \
	 echo "$(YELLOW)‚ö†Ô∏è  Integration tests failed (may need Swift bridge)$(NC)"
	@$(PYTHON) -m pytest tests/integration/mcp/test_apple_foundation_models.py -v || \
	 echo "$(YELLOW)‚ö†Ô∏è  Python integration tests failed$(NC)"

##@ Sprint Automation

sprint-start: ## Run sprint start workflow (clean backlog, align tasks)
	@echo "$(BLUE)Running sprint start workflow...$(NC)"
	@if [ -f $(BINARY_PATH) ]; then \
		$(BINARY_PATH) -tool automation -args '{"action":"sprint","run_analysis_tools":true,"run_testing_tools":false,"extract_subtasks":true,"auto_approve":true,"max_iterations":1}' || \
		echo "$(YELLOW)‚ö†Ô∏è  Sprint start workflow completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Sprint start workflow complete$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		$(BINARY_PATH) -tool automation -args '{"action":"sprint","run_analysis_tools":true,"run_testing_tools":false,"extract_subtasks":true,"auto_approve":true,"max_iterations":1}' || \
		echo "$(YELLOW)‚ö†Ô∏è  Sprint start workflow completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Sprint start workflow complete$(NC)"; \
	fi

sprint-end: ## Run sprint end workflow (test coverage, docs, security)
	@echo "$(BLUE)Running sprint end workflow...$(NC)"
	@if [ -f $(BINARY_PATH) ]; then \
		$(MAKE) test-coverage; \
		$(BINARY_PATH) -tool health -args '{"action":"docs"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Docs health check completed$(NC)"; \
		$(BINARY_PATH) -tool security -args '{"action":"report"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Security check completed$(NC)"; \
		echo "$(GREEN)‚úÖ Sprint end workflow complete$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		$(MAKE) test-coverage; \
		$(BINARY_PATH) -tool health -args '{"action":"docs"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Docs health check completed$(NC)"; \
		$(BINARY_PATH) -tool security -args '{"action":"report"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Security check completed$(NC)"; \
		echo "$(GREEN)‚úÖ Sprint end workflow complete$(NC)"; \
	fi

pre-sprint: ## Run pre-sprint cleanup (duplicates, alignment, docs)
	@echo "$(BLUE)Running pre-sprint cleanup...$(NC)"
	@if [ -f $(BINARY_PATH) ]; then \
		$(BINARY_PATH) -tool task_analysis -args '{"action":"duplicates"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Duplicate detection completed$(NC)"; \
		$(BINARY_PATH) -tool analyze_alignment -args '{"action":"todo2"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Alignment analysis completed$(NC)"; \
		$(BINARY_PATH) -tool health -args '{"action":"docs"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Docs health check completed$(NC)"; \
		echo "$(GREEN)‚úÖ Pre-sprint cleanup complete$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		$(BINARY_PATH) -tool task_analysis -args '{"action":"duplicates"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Duplicate detection completed$(NC)"; \
		$(BINARY_PATH) -tool analyze_alignment -args '{"action":"todo2"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Alignment analysis completed$(NC)"; \
		$(BINARY_PATH) -tool health -args '{"action":"docs"}' 2>/dev/null || echo "$(YELLOW)‚ö†Ô∏è  Docs health check completed$(NC)"; \
		echo "$(GREEN)‚úÖ Pre-sprint cleanup complete$(NC)"; \
	fi

sprint: ## Run full sprint automation (process all background tasks)
	@echo "$(BLUE)Running sprint automation...$(NC)"
	@if [ -f $(BINARY_PATH) ]; then \
		$(BINARY_PATH) -tool automation -args '{"action":"sprint","max_iterations":10,"auto_approve":true,"extract_subtasks":true,"run_analysis_tools":true,"run_testing_tools":true}' || \
		echo "$(YELLOW)‚ö†Ô∏è  Sprint automation completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Sprint automation complete$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  exarp-go binary not found$(NC)"; \
		echo "$(YELLOW)   Building binary first...$(NC)"; \
		$(MAKE) build; \
		$(BINARY_PATH) -tool automation -args '{"action":"sprint","max_iterations":10,"auto_approve":true,"extract_subtasks":true,"run_analysis_tools":true,"run_testing_tools":true}' || \
		echo "$(YELLOW)‚ö†Ô∏è  Sprint automation completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Sprint automation complete$(NC)"; \
	fi

check-tasks: ## Batch check all Todo and In Progress tasks to find completed ones (dry run)
	@echo "$(BLUE)Checking tasks for completion (dry run)...$(NC)"
	@if command -v python3 >/dev/null 2>&1; then \
		cd $(shell pwd) && python3 -c "import sys; sys.path.insert(0, '.'); from project_management_automation.tools.auto_update_task_status import auto_update_task_status; import json; result = auto_update_task_status(confidence_threshold=0.7, auto_update_tasks=False, dry_run=True, output_path='docs/TASK_COMPLETION_CHECK.md'); print(result)" || \
		echo "$(YELLOW)‚ö†Ô∏è  Task check completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Task completion check complete (dry run)$(NC)"; \
	elif command -v uv >/dev/null 2>&1 || [ -x "$$HOME/.cargo/bin/uv" ] || [ -x "$$HOME/.local/bin/uv" ]; then \
		$(PYTHON) -c "from project_management_automation.tools.auto_update_task_status import auto_update_task_status; import json; result = auto_update_task_status(confidence_threshold=0.7, auto_update_tasks=False, dry_run=True, output_path='docs/TASK_COMPLETION_CHECK.md'); print(result)" || \
		echo "$(YELLOW)‚ö†Ô∏è  Task check completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Task completion check complete (dry run)$(NC)"; \
	else \
		echo "$(RED)‚ùå Python not found - cannot run task completion check$(NC)"; \
		echo "$(YELLOW)   Install Python 3 or uv: curl -LsSf https://astral.sh/uv/install.sh | sh$(NC)"; \
		exit 1; \
	fi

update-completed-tasks: ## Batch check and auto-update completed tasks (updates task status)
	@echo "$(BLUE)Checking and updating completed tasks...$(NC)"
	@echo "$(YELLOW)‚ö†Ô∏è  This will update task statuses based on codebase analysis$(NC)"
	@if command -v python3 >/dev/null 2>&1; then \
		cd $(shell pwd) && python3 -c "import sys; sys.path.insert(0, '.'); from project_management_automation.tools.auto_update_task_status import auto_update_task_status; import json; result = auto_update_task_status(confidence_threshold=0.7, auto_update_tasks=True, dry_run=False, output_path='docs/TASK_COMPLETION_UPDATE.md'); print(result)" || \
		echo "$(YELLOW)‚ö†Ô∏è  Task update completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Completed tasks updated$(NC)"; \
	elif command -v uv >/dev/null 2>&1 || [ -x "$$HOME/.cargo/bin/uv" ] || [ -x "$$HOME/.local/bin/uv" ]; then \
		$(PYTHON) -c "from project_management_automation.tools.auto_update_task_status import auto_update_task_status; import json; result = auto_update_task_status(confidence_threshold=0.7, auto_update_tasks=True, dry_run=False, output_path='docs/TASK_COMPLETION_UPDATE.md'); print(result)" || \
		echo "$(YELLOW)‚ö†Ô∏è  Task update completed (check output above)$(NC)"; \
		echo "$(GREEN)‚úÖ Completed tasks updated$(NC)"; \
	else \
		echo "$(RED)‚ùå Python not found - cannot run task completion update$(NC)"; \
		echo "$(YELLOW)   Install Python 3 or uv: curl -LsSf https://astral.sh/uv/install.sh | sh$(NC)"; \
		exit 1; \
	fi

##@ Data Migration

migrate: build-migrate ## Run JSON to SQLite migration tool (requires build-migrate first)
	@echo "$(BLUE)Running migration tool...$(NC)"
	@./bin/migrate --backup || (echo "$(RED)‚ùå Migration failed$(NC)" && exit 1)

migrate-dry-run: build-migrate ## Preview migration without actually migrating
	@echo "$(BLUE)Running migration tool (dry run)...$(NC)"
	@./bin/migrate --dry-run

##@ Quick Commands

quick-test: test-tools ## Quick test (tools only)
quick-dev: dev ## Quick dev mode (watch only)
quick-build: build ## Quick build (verify imports)

##@ Model-Assisted Testing (Future)

test-models: ## Test model integration (MLX/Ollama)
	@echo "$(BLUE)Testing model integration...$(NC)"
	@echo "$(YELLOW)Model integration testing via Go server$(NC)"

test-breakdown: ## Test task breakdown with models
	@echo "$(BLUE)Testing task breakdown...$(NC)"
	@echo "$(YELLOW)Model-assisted testing not yet implemented$(NC)"

test-auto-exec: ## Test auto-execution with models
	@echo "$(BLUE)Testing auto-execution...$(NC)"
	@echo "$(YELLOW)Model-assisted testing not yet implemented$(NC)"

